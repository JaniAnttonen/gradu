
@techreport{boneh_verifiable_2018,
	title = {Verifiable {Delay} {Functions}},
	url = {http://eprint.iacr.org/2018/601},
	abstract = {We study the problem of building a verifiable delay function (VDF). A VDF requires a specified number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified. VDFs have many applications in decentralized systems, including public randomness beacons, leader election in consensus protocols, and proofs of replication. We formalize the requirements for VDFs and present new candidate constructions that are the first to achieve an exponential gap between evaluation and verification time.},
	number = {601},
	urldate = {2020-01-19},
	author = {Boneh, Dan and Bonneau, Joseph and Bünz, Benedikt and Fisch, Ben},
	year = {2018},
	keywords = {cryptographic protocols, proof of sequential work, RSA,, time-lock puzzle, VDF},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/HEDDBRJH/Boneh et al. - 2018 - Verifiable Delay Functions.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/PHSRLXFF/601.html:text/html}
}

@inproceedings{boneh_verifiable_2018-1,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Verifiable {Delay} {Functions}},
	isbn = {978-3-319-96884-1},
	doi = {10.1007/978-3-319-96884-1_25},
	abstract = {We study the problem of building a verifiable delay function (VDF). A VDFVDF{\textbackslash}text \{VDF\}requires a specified number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified. VDFVDF{\textbackslash}text \{VDF\}s have many applications in decentralized systems, including public randomness beacons, leader election in consensus protocols, and proofs of replication. We formalize the requirements for VDFVDF{\textbackslash}text \{VDF\}s and present new candidate constructions that are the first to achieve an exponential gap between evaluation and verification time.},
	language = {en},
	booktitle = {Advances in {Cryptology} – {CRYPTO} 2018},
	publisher = {Springer International Publishing},
	author = {Boneh, Dan and Bonneau, Joseph and Bünz, Benedikt and Fisch, Ben},
	editor = {Shacham, Hovav and Boldyreva, Alexandra},
	year = {2018},
	pages = {757--788},
	file = {Springer Full Text PDF:/home/jani/Zotero/storage/J9CU8QGJ/Boneh et al. - 2018 - Verifiable Delay Functions.pdf:application/pdf}
}

@inproceedings{wesolowski_efficient_2019,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Efficient {Verifiable} {Delay} {Functions}},
	isbn = {978-3-030-17659-4},
	doi = {10.1007/978-3-030-17659-4_13},
	abstract = {We construct a verifiable delay function (VDF). A VDF is a function whose evaluation requires running a given number of sequential steps, yet the result can be efficiently verified. They have applications in decentralised systems, such as the generation of trustworthy public randomness in a trustless environment, or resource-efficient blockchains. To construct our VDF, we actually build a trapdoor VDF. A trapdoor VDF is essentially a VDF which can be evaluated efficiently by parties who know a secret (the trapdoor). By setting up this scheme in a way that the trapdoor is unknown (not even by the party running the setup, so that there is no need for a trusted setup environment), we obtain a simple VDF. Our construction is based on groups of unknown order such as an RSA group, or the class group of an imaginary quadratic field. The output of our construction is very short (the result and the proof of correctness are each a single element of the group), and the verification of correctness is very efficient.},
	language = {en},
	booktitle = {Advances in {Cryptology} – {EUROCRYPT} 2019},
	publisher = {Springer International Publishing},
	author = {Wesolowski, Benjamin},
	editor = {Ishai, Yuval and Rijmen, Vincent},
	year = {2019},
	pages = {379--407},
	file = {Springer Full Text PDF:/home/jani/Zotero/storage/4FNZGG4K/Wesolowski - 2019 - Efficient Verifiable Delay Functions.pdf:application/pdf}
}

@article{dean_using_nodate,
	title = {Using {Client} {Puzzles} to {Protect} {TLS}},
	abstract = {Client puzzles are commonly proposed as a solution to denial-of-service attacks. However, very few implementations of the idea actually exist, and there are a number of subtle details in the implementation. In this paper, we describe our implementation of a simple and backwards compatible client puzzle extension to TLS. We also present measurements of CPU load and latency when our modiﬁed library is used to protect a secure webserver. These measurements show that client puzzles are a viable method for protecting SSL servers from SSL based denial-of-service attacks.},
	language = {en},
	author = {Dean, Drew and Stubbleﬁeld, Adam},
	pages = {9},
	file = {Dean and Stubbleﬁeld - Using Client Puzzles to Protect TLS.pdf:/home/jani/Zotero/storage/SQMZPDDP/Dean and Stubbleﬁeld - Using Client Puzzles to Protect TLS.pdf:application/pdf}
}

@inproceedings{micali_verifiable_1999,
	address = {New York City, NY, USA},
	title = {Verifiable random functions},
	isbn = {978-0-7695-0409-4},
	url = {http://ieeexplore.ieee.org/document/814584/},
	doi = {10.1109/SFFCS.1999.814584},
	language = {en},
	urldate = {2020-01-19},
	booktitle = {40th {Annual} {Symposium} on {Foundations} of {Computer} {Science} ({Cat}. {No}.{99CB37039})},
	publisher = {IEEE Comput. Soc},
	author = {Micali, S. and Rabin, M. and Vadhan, S.},
	year = {1999},
	pages = {120--130},
	file = {Micali et al. - 1999 - Verifiable random functions.pdf:/home/jani/Zotero/storage/4T8445JV/Micali et al. - 1999 - Verifiable random functions.pdf:application/pdf}
}

@techreport{brewer_spanner_2017,
	title = {Spanner, {TrueTime} and the {CAP} {Theorem}},
	author = {Brewer, Eric},
	year = {2017},
	file = {Full Text PDF:/home/jani/Zotero/storage/GU8NPN5W/Brewer - 2017 - Spanner, TrueTime and the CAP Theorem.pdf:application/pdf}
}

@misc{noauthor_cloud_nodate,
	title = {Cloud {Spanner}: {TrueTime} and external consistency {\textbar} {Cloud} {Spanner}},
	shorttitle = {Cloud {Spanner}},
	url = {https://cloud.google.com/spanner/docs/true-time-external-consistency},
	language = {en},
	urldate = {2020-01-19},
	journal = {Google Cloud},
	file = {Snapshot:/home/jani/Zotero/storage/RXHSULPE/true-time-external-consistency.html:text/html}
}

@misc{babybluehy_introduction_2018,
	title = {Introduction to {Verifiable} {Delay} {Functions} ({VDFs})},
	url = {https://blog.trailofbits.com/2018/10/12/introduction-to-verifiable-delay-functions-vdfs/},
	abstract = {Finding randomness on the blockchain is hard. A classic mistake developers make when trying to acquire a random value on-chain is to use quantities like future block hashes, block difficulty, or ti…},
	language = {en},
	urldate = {2020-01-19},
	journal = {Trail of Bits Blog},
	author = {{babybluehy}},
	month = oct,
	year = {2018},
	annote = {"Think of VDF’s as a time delay imposed on the output of some pseudorandom generator. This delay prevents malicious actors from influencing the output of the pseudorandom generator, since all inputs will be finalized before anyone can finish computing the VDF."},
	file = {Snapshot:/home/jani/Zotero/storage/ZMFPQRQ3/introduction-to-verifiable-delay-functions-vdfs.html:text/html}
}

@misc{noauthor_proof_2018,
	title = {Proof of {History}: {A} {Clock} for {Blockchain}},
	shorttitle = {Proof of {History}},
	url = {https://solana.com/proof-of-history/},
	abstract = {A high-level explanation of Solana’s core innovation Solana is the most performant permissionless blockchain in the world. On current iterations...},
	language = {en-US},
	urldate = {2020-01-19},
	journal = {Blockchain Rebuilt for Scale - Solana},
	month = apr,
	year = {2018},
	file = {Snapshot:/home/jani/Zotero/storage/RQ5SFSIT/proof-of-history.html:text/html}
}

@article{yakovenko_solana_nodate,
	title = {Solana: {A} new architecture for a high performance blockchain},
	abstract = {This paper proposes a new blockchain architecture based on Proof of History (PoH) - a proof for verifying order and passage of time between events. PoH is used to encode trustless passage of time into a ledger - an append only data structure. When used alongside a consensus algorithm such as Proof of Work (PoW) or Proof of Stake (PoS), PoH can reduce messaging overhead in a Byzantine Fault Tolerant replicated state machine, resulting in sub-second finality times. This paper also proposes two algorithms that leverage the time keeping properties of the PoH ledger - a PoS algorithm that can recover from partitions of any size and an efficient streaming Proof of Replication (PoRep). The combination of PoRep and PoH provides a defense against forgery of the ledger with respect to time (ordering) and storage. The protocol is analyzed on a 1 gbps network, and this paper shows that throughput up to 710k transactions per second is possible with today’s hardware.},
	language = {en},
	author = {Yakovenko, Anatoly},
	pages = {32},
	file = {Yakovenko - Solana A new architecture for a high performance .pdf:/home/jani/Zotero/storage/7K3LF67J/Yakovenko - Solana A new architecture for a high performance .pdf:application/pdf}
}

@article{liskov_practical_nodate,
	title = {Practical {Usesof} {Synchronized} {Clocks} undistributed {Systems}},
	abstract = {Synchronized clocks areinteresting because they can be used to improve performance of a distributed system by reducing communication. Since they have only recently become a reality in distributed systems, their use in distributed algorithms has received relatively little attention. This paper discusses a number of dktributed algorithms that make use of synchronized clocks and analyzes how clocks are used in these algorithms.},
	language = {en},
	author = {Liskov, Barbara},
	pages = {9},
	file = {Liskov - Practical Usesof Synchronized Clocks undistributed.pdf:/home/jani/Zotero/storage/6XWKLUT4/Liskov - Practical Usesof Synchronized Clocks undistributed.pdf:application/pdf}
}

@techreport{boneh_verifiable_2018-2,
	title = {Verifiable {Delay} {Functions}},
	url = {http://eprint.iacr.org/2018/601},
	abstract = {We study the problem of building a verifiable delay function (VDF). A VDF requires a specified number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified. VDFs have many applications in decentralized systems, including public randomness beacons, leader election in consensus protocols, and proofs of replication. We formalize the requirements for VDFs and present new candidate constructions that are the first to achieve an exponential gap between evaluation and verification time.},
	number = {601},
	urldate = {2020-01-20},
	author = {Boneh, Dan and Bonneau, Joseph and Bünz, Benedikt and Fisch, Ben},
	year = {2018},
	keywords = {cryptographic protocols, proof of sequential work, RSA,, time-lock puzzle, VDF},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/DE6U9SIQ/Boneh et al. - 2018 - Verifiable Delay Functions.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/VI2WUI9Z/601.html:text/html}
}

@techreport{bowe_zexe_2018,
	title = {Zexe: {Enabling} {Decentralized} {Private} {Computation}},
	shorttitle = {Zexe},
	url = {https://eprint.iacr.org/2018/962},
	abstract = {Ledger-based systems that support rich applications often suffer from two limitations. First, validating a transaction requires re-executing the state transition that it attests to. Second, transactions not only reveal which application had a state transition but also reveal the application's internal state.



We design, implement, and evaluate ZEXE, a ledger-based system where users can execute offline computations and subsequently produce transactions, attesting to the correctness of these computations, that satisfy two main properties. First, transactions *hide all information* about the offline computations. Second, transactions can be *validated in constant time* by anyone, regardless of the offline computation.

The core of ZEXE is a construction for a new cryptographic primitive that we introduce, *decentralized private computation* (DPC) schemes. In order to achieve an efficient implementation of our construction, we leverage tools in the area of cryptographic proofs, including succinct zero knowledge proofs and recursive proof composition. Overall, transactions in ZEXE are 968 bytes regardless of the offline computation, and generating them takes less than a minute plus a time that grows with the offline computation.

We demonstrate how to use ZEXE to realize privacy-preserving analogues of popular applications: private decentralized exchanges for user-defined fungible assets and regulation-friendly private stablecoins.},
	number = {962},
	urldate = {2020-01-20},
	author = {Bowe, Sean and Chiesa, Alessandro and Green, Matthew and Miers, Ian and Mishra, Pratyush and Wu, Howard},
	year = {2018},
	keywords = {cryptographic protocols, decentralized computation; zero knowledge proofs; succinct arguments},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/3QGDIJJ6/Bowe et al. - 2018 - Zexe Enabling Decentralized Private Computation.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/YXV7IRVN/962.html:text/html}
}

@article{meckler_coda_nodate,
	title = {Coda: {Decentralized} cryptocurrency at scale},
	abstract = {We present Coda, the ﬁrst cryptocurrency protocol that remains decentralized at scale. “Scalability” refers to Coda’s ability to handle throughput of thousands of transactions per second. “Decentralization” refers to the accessibility of verifying the chain state and synchronizing as a new user. Synchronizing the chain state with Coda requires receiving less than a megabyte of data, allowing devices like smartphones to securely perform transactions independent of how long the protocol has been running or how many transactions have been performed. Transactions on Coda can also be veriﬁed independent of their complexity, allowing complex computations on its blockchain without burdening the network. Coda achieves these features without sacriﬁcing either scaling or decentralization through the use of recursive composition of zk-SNARKs in a novel architecture that implements a decentralized ledger. The resulting consensus protocol is consistent and responsive as long as at most 1/2 of the mining power is T malicious.},
	language = {en},
	author = {Meckler, Izaak and Shapiro, Evan},
	pages = {8},
	file = {Meckler and Shapiro - Coda Decentralized cryptocurrency at scale.pdf:/home/jani/Zotero/storage/P7QEJ5NA/Meckler and Shapiro - Coda Decentralized cryptocurrency at scale.pdf:application/pdf}
}

@misc{noauthor_causal_nodate,
	title = {Causal ordering},
	url = {https://scattered-thoughts.net/writing/causal-ordering/},
	urldate = {2020-01-24},
	file = {Causal ordering:/home/jani/Zotero/storage/6XDF34TU/causal-ordering.html:text/html}
}

@misc{joshi_ordering_2019,
	title = {Ordering {Distributed} {Events}},
	url = {https://medium.com/baseds/ordering-distributed-events-29c1dd9d1eff},
	abstract = {One of the hardest things about distributed systems is that we often find ourselves needing to approach them very differently than other…},
	language = {en},
	urldate = {2020-01-24},
	journal = {Medium},
	author = {Joshi, Vaidehi},
	month = oct,
	year = {2019},
	file = {Snapshot:/home/jani/Zotero/storage/TTAFBI88/ordering-distributed-events-29c1dd9d1eff.html:text/html}
}

@article{corbett_spanner_2012,
	title = {Spanner: {Google}’s {Globally}-{Distributed} {Database}},
	abstract = {Spanner is Google’s scalable, multi-version, globallydistributed, and synchronously-replicated database. It is the ﬁrst system to distribute data at global scale and support externally-consistent distributed transactions. This paper describes how Spanner is structured, its feature set, the rationale underlying various design decisions, and a novel time API that exposes clock uncertainty. This API and its implementation are critical to supporting external consistency and a variety of powerful features: nonblocking reads in the past, lock-free read-only transactions, and atomic schema changes, across all of Spanner.},
	language = {en},
	author = {Corbett, James C and Dean, Jeffrey and Epstein, Michael and Fikes, Andrew and Frost, Christopher and Furman, JJ and Ghemawat, Sanjay and Gubarev, Andrey and Heiser, Christopher and Hochschild, Peter and Hsieh, Wilson and Kanthak, Sebastian and Kogan, Eugene and Li, Hongyi and Lloyd, Alexander and Melnik, Sergey and Mwaura, David and Nagle, David and Quinlan, Sean and Rao, Rajesh and Rolig, Lindsay and Saito, Yasushi and Szymaniak, Michal and Taylor, Christopher and Wang, Ruth and Woodford, Dale},
	year = {2012},
	pages = {14},
	file = {Corbett et al. - 2012 - Spanner Google’s Globally-Distributed Database.pdf:/home/jani/Zotero/storage/JESAFG9P/Corbett et al. - 2012 - Spanner Google’s Globally-Distributed Database.pdf:application/pdf}
}

@article{barbara_proof_2019,
	title = {Proof of {All}: {Verifiable} {Computation} in a {Nutshell}},
	shorttitle = {Proof of {All}},
	url = {http://arxiv.org/abs/1908.02327},
	abstract = {Recent advances in the cryptographic field of "Zero-Knowledge Proofs" have sparked a new wave of research, giving birth to many exciting theoretical approaches in the last few years. Such research has often overlapped with the need for private and scalable solutions of Blockchain-based communities, resulting in the first practical implementations of such systems. Many of these innovative constructions have developed in parallel, using different terminologies and evolving into a fragmented ecosystem, calling for their consolidation into the more stable domain of "Verifiable Computation". In this master thesis I propose a unifying Verifiable Computation model for the simplification and efficient comparison of all cryptographic proof systems. I take advantage of this model to analyse innovative technologies (Homomorphic Authenticators, Verifiable Delay Functions) which developed into their own specialised domains, and I attempt to make them more accessible for newcomers to the field. Furthermore, I expand on the future of Verifiable Computation, Universal proof compilers and "Proofs of All", by approaching the state-of-the-art zk-STARK construction from a more accessible and informal design perspective.},
	urldate = {2020-02-11},
	journal = {arXiv:1908.02327 [cs]},
	author = {Barbara, Mario Alessandro},
	month = aug,
	year = {2019},
	note = {arXiv: 1908.02327},
	keywords = {Computer Science - Cryptography and Security},
	annote = {Comment: 71 pages, 1 figure, MSc. Thesis E{\textbackslash}"otv{\textbackslash}"os Lor{\textbackslash}'and University (in collaboration with University of Twente through European Institue of Technology Master School scholarship)},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/MHWREK9I/Barbara - 2019 - Proof of All Verifiable Computation in a Nutshell.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/3CD239KC/1908.html:text/html}
}

@article{long_nakamoto_2020,
	title = {Nakamoto {Consensus} with {Verifiable} {Delay} {Puzzle}},
	url = {http://arxiv.org/abs/1908.06394},
	abstract = {This paper summarizes our work-in-progress on a new consensus protocol based on verifiable delay function. First, we introduce the concept of verifiable delay puzzle (VDP), which resembles the hashing puzzle used in the PoW mechanism but can only be solved sequentially. We then present a VDP implementation based on Pietrzak's verifiable delay function. Further, we show that VDP can be combined with the Nakamoto consensus in a proof-of-stake/proof-of-delay hybrid protocol. We analyze the persistence and liveness of the protocol, and show that compared to PoW, our proposal consumes much less energy; compared to BFT based consensus algorithms which usually place an upper limit on the number of consensus nodes, our proposal is much more scalable and can thus achieve a higher level of decentralization.},
	urldate = {2020-02-11},
	journal = {arXiv:1908.06394 [cs]},
	author = {Long, Jieyi and Wei, Ribao},
	month = jan,
	year = {2020},
	note = {arXiv: 1908.06394},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/V25E2USP/Long and Wei - 2020 - Nakamoto Consensus with Verifiable Delay Puzzle.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/QKA45T32/1908.html:text/html}
}

@article{chen_dexon_2018,
	title = {{DEXON}: {A} {Highly} {Scalable}, {Decentralized} {DAG}-{Based} {Consensus} {Algorithm}},
	shorttitle = {{DEXON}},
	url = {http://arxiv.org/abs/1811.07525},
	abstract = {A blockchain system is a replicated state machine that must be fault tolerant. When designing a blockchain system, there is usually a trade-off between decentralization, scalability, and security. In this paper, we propose a novel blockchain system, DEXON, which achieves high scalability while remaining decentralized and robust in the real-world environment. We have two main contributions. First, we present a highly scalable sharding framework for blockchain. This framework takes an arbitrary number of single chains and transforms them into the {\textbackslash}textit\{blocklattice\} data structure, enabling {\textbackslash}textit\{high scalability\} and {\textbackslash}textit\{low transaction confirmation latency\} with asymptotically optimal communication overhead. Second, we propose a single-chain protocol based on our novel verifiable random function and a new Byzantine agreement that achieves high decentralization and low latency.},
	urldate = {2020-02-11},
	journal = {arXiv:1811.07525 [cs]},
	author = {Chen, Tai-Yuan and Huang, Wei-Ning and Kuo, Po-Chun and Chung, Hao and Chao, Tzu-Wei},
	month = nov,
	year = {2018},
	note = {arXiv: 1811.07525},
	keywords = {Computer Science - Cryptography and Security, Computer Science - Distributed, Parallel, and Cluster Computing, Computer Science - Databases},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/HGPGR2RK/Chen et al. - 2018 - DEXON A Highly Scalable, Decentralized DAG-Based .pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/U3MSZ9RM/1811.html:text/html}
}

@article{hanke_dfinity_2018,
	title = {{DFINITY} {Technology} {Overview} {Series}, {Consensus} {System}},
	url = {http://arxiv.org/abs/1805.04548},
	abstract = {The DFINITY blockchain computer provides a secure, performant and flexible consensus mechanism. At its core, DFINITY contains a decentralized randomness beacon which acts as a verifiable random function (VRF) that produces a stream of outputs over time. The novel technique behind the beacon relies on the existence of a unique-deterministic, non-interactive, DKG-friendly threshold signatures scheme. The only known examples of such a scheme are pairing-based and derived from BLS. The DFINITY blockchain is layered on top of the DFINITY beacon and uses the beacon as its source of randomness for leader selection and leader ranking. A "weight" is attributed to a chain based on the ranks of the leaders who propose the blocks in the chain, and that weight is used to select between competing chains. The DFINITY blockchain is layered on top of the DFINITY beacon and uses the beacon as its source of randomness for leader selection and leader ranking blockchain is further hardened by a notarization process which dramatically improves the time to finality and eliminates the nothing-at-stake and selfish mining attacks. DFINITY consensus algorithm is made to scale through continuous quorum selections driven by the random beacon. In practice, DFINITY achieves block times of a few seconds and transaction finality after only two confirmations. The system gracefully handles temporary losses of network synchrony including network splits, while it is provably secure under synchrony.},
	urldate = {2020-02-11},
	journal = {arXiv:1805.04548 [cs]},
	author = {Hanke, Timo and Movahedi, Mahnush and Williams, Dominic},
	month = may,
	year = {2018},
	note = {arXiv: 1805.04548},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/9WT2NLHI/Hanke et al. - 2018 - DFINITY Technology Overview Series, Consensus Syst.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/7PCJMKXK/1805.html:text/html}
}

@inproceedings{dharanikot_breeding_2019,
	title = {Breeding {Unicorns}: {Developing} {Trustworthy} and {Scalable} {Randomness} {Beacons}},
	shorttitle = {Breeding {Unicorns}},
	doi = {10.1109/Blockchain.2019.00022},
	abstract = {Randomness beacons are services that periodically emit a random number, allowing users to agree on the same random outcome without trusting anyone: ideally, the randomness beacon is secure (cannot be influenced) and transparent (can be monitored by users). Hence, such randomness beacons can serve as an important primitive for smart contracts in a variety of contexts. In this paper we aim to bridge the gap between theory and practice of public beacon design inspired by the unicorn protocol of Lenstra and Wesolowski using verifiable delay functions. We first present a structured security analysis, based on which we design, implement, and evaluate a trustworthy and efficient randomness beacon allowing users to join at any time. We then compare different implementation and deployment options on distributed ledgers, and report on a Ethereum smart contract-based lottery using our beacon.},
	booktitle = {2019 {IEEE} {International} {Conference} on {Blockchain} ({Blockchain})},
	author = {Dharanikot, Samvid and Jensen, Michael Toft and Kristensen, Sebastian Rom and Michno, Mathias Sass and Pignolet, Yvonne-Anne and Rydhof Hansen, René and Schmid, Stefan},
	month = jul,
	year = {2019},
	note = {ISSN: null},
	keywords = {cryptographic protocols, contracts, data privacy, distributed ledgers, efficient randomness beacon, Ethereum smart contract-based lottery, public beacon design, Random beacon, transparency, smart contract, random number, scalable randomness beacons, structured security analysis, trusted computing, trustworthy randomness beacon, unicorn protocol, verifiable delay functions},
	pages = {99--106},
	file = {IEEE Xplore Abstract Record:/home/jani/Zotero/storage/XY84XA5G/8946167.html:text/html;IEEE Xplore Full Text PDF:/home/jani/Zotero/storage/Q3QV67VR/Dharanikot et al. - 2019 - Breeding Unicorns Developing Trustworthy and Scal.pdf:application/pdf}
}

@article{ozturk_design_2020,
	title = {Design and {Implementation} of a {Low}-{Latency} {Modular} {Multiplication} {Algorithm}},
	issn = {1558-0806},
	doi = {10.1109/TCSI.2020.2966755},
	abstract = {Modular multiplication is one of the most compute-intensive arithmetic operations. Most public-key cryptosystems utilize modular multiplication of integers of various lengths, depending on security requirements. Efficient algorithms and implementations are required to realize a practical public-key cryptosystem. Different parameters, such as area, power and time, can be optimized for different implementation requirements. Low latency was not as important as high throughput requirement for modular multiplication implementations before. However, with recent work on Verifiable Delay Functions (VDFs), a necessity for the lowest possible latency for modular multiplication implementations emerged. VDFs are designed to take a prescribed time to realize the underlying computation that can be publicly verified. VDF constructions utilize inherently sequential arithmetic operations. Efficient VDF constructions have been proposed recently, based on time-lock puzzles constructed by Rivest, Shamir, and Wagner. An exponentiation operation in an RSA group needs to be realized for these VDF constructions. In this paper, a modular multiplication algorithm suitable for low-latency circuit implementations is proposed and an FPGA-optimized variant of this algorithm is presented.},
	journal = {IEEE Transactions on Circuits and Systems I: Regular Papers},
	author = {Öztürk, Erdinç},
	year = {2020},
	keywords = {FPGA, low-latency circuit design., modular multiplication, reduction, Verifiable delay function (VDF)},
	pages = {1--10},
	file = {IEEE Xplore Abstract Record:/home/jani/Zotero/storage/PHB9D5ZQ/8968620.html:text/html}
}

@book{international_conference_on_the_theory_and_application_of_cryptology_and_information_security_advances_2019,
	address = {Cham},
	title = {Advances in {Cryptology} -- {ASIACRYPT} 2019 25th {International} {Conference} on the {Theory} and {Application} of {Cryptology} and {Information} {Security}, {Kobe}, {Japan}, {December} 8-12, 2019, {Proceedings}. {Part} {I} {Part} {I}},
	isbn = {978-3-030-34578-5},
	url = {http://public.eblib.com/choice/PublicFullRecord.aspx?p=5984510},
	abstract = {The three-volume set of LNCS 11921,11922, and 11923 constitutes the refereed proceedings of the 25th International Conference on the Theory and Applications of Cryptology and Information Security, ASIACRYPT 2019, held in Kobe, Japan, in December 2019. The 71 revised full papers presented were carefully reviewed and selected from 307 submissions. They are organized in topical sections on Lattices; Symmetric Cryptography; Isogenies; Obfuscation; Multiparty Computation; Quantum; E-cash and Blockchain; Codes; Authenticated Encryption; Multilinear Maps; Homomorphic Encryption; Combinatorial Cryptography; Signatures; Public Key Encryption; Side Channels; Functional Encryption; Zero Knowledge.},
	language = {en},
	urldate = {2020-02-11},
	publisher = {Springer},
	author = {{International Conference on the Theory and Application of Cryptology and Information Security} and Galbraith, Steven D and Moriai, Shiho},
	year = {2019},
	note = {OCLC: 1129182869},
	file = {International Conference on the Theory and Application of Cryptology and Information Security et al. - 2019 - Advances in Cryptology -- ASIACRYPT 2019 25th Inte.pdf:/home/jani/Zotero/storage/DKJB2342/International Conference on the Theory and Application of Cryptology and Information Security et al. - 2019 - Advances in Cryptology -- ASIACRYPT 2019 25th Inte.pdf:application/pdf}
}

@techreport{moran_simple_2016,
	title = {Simple {Proofs} of {Space}-{Time} and {Rational} {Proofs} of {Storage}},
	url = {http://eprint.iacr.org/2016/035},
	abstract = {We introduce a new cryptographic primitive: Proofs of Space-Time (PoSTs) and construct an extremely simple, practical protocol for implementing these proofs. A PoST allows a prover to convince a verifier that she spent a ``space-time'' resource (storing data---space---over a period of time). Formally, we define the PoST resource as a trade-off between CPU work and space-time (under reasonable cost assumptions, a rational user will prefer to use the lower-cost space-time resource over CPU work).



Compared to a proof-of-work, a PoST requires less energy use, as the ``difficulty'' can be increased by extending the time period over which data is stored without increasing computation costs. Our definition is very similar to ``Proofs of Space'' [ePrint 2013/796, 2013/805] but, unlike the previous definitions, takes into account amortization attacks and storage duration. Moreover, our protocol uses a very different (and much simpler) technique, making use of the fact that we explicitly allow a space-time tradeoff, and doesn't require any non-standard assumptions (beyond random oracles). Unlike previous constructions, our protocol allows incremental difficulty adjustment, which can gracefully handle increases in the price of storage compared to CPU work. In addition, we show how, in a cryptocurrency context, the parameters of the scheme can be adjusted using a market-based mechanism, similar in spirit to the difficulty adjustment for PoW protocols.},
	number = {035},
	urldate = {2020-02-11},
	author = {Moran, Tal and Orlov, Ilan},
	year = {2016},
	keywords = {cryptographic protocols, bitcoin, crypto-currency, proofs of space, proofs of work},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/3JTTCI9H/Moran and Orlov - 2016 - Simple Proofs of Space-Time and Rational Proofs of.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/ZHQ8Q7LH/035.html:text/html}
}

@misc{noauthor_proofs_2018,
	title = {Proofs of {Space} {Time} {ASICs}},
	url = {https://spacemesh.io/post-asic/},
	abstract = {In this blog post, Spacemesh clarifies why we believe that PoST is a viable alternative to PoStake and PoW.},
	language = {en},
	urldate = {2020-02-11},
	journal = {Spacemesh},
	month = jun,
	year = {2018},
	file = {Snapshot:/home/jani/Zotero/storage/46IHI8YZ/post-asic.html:text/html}
}

@techreport{boneh_verifiable_2018-3,
	title = {Verifiable {Delay} {Functions}},
	url = {https://eprint.iacr.org/2018/601},
	abstract = {We study the problem of building a verifiable delay function (VDF). A VDF requires a specified number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified. VDFs have many applications in decentralized systems, including public randomness beacons, leader election in consensus protocols, and proofs of replication. We formalize the requirements for VDFs and present new candidate constructions that are the first to achieve an exponential gap between evaluation and verification time.},
	number = {601},
	urldate = {2020-02-11},
	author = {Boneh, Dan and Bonneau, Joseph and Bünz, Benedikt and Fisch, Ben},
	year = {2018},
	keywords = {cryptographic protocols, proof of sequential work, RSA,, time-lock puzzle, VDF},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/72R4DD6I/Boneh et al. - 2018 - Verifiable Delay Functions.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/HGXU3589/601.html:text/html}
}

@article{boneh_survey_nodate,
	title = {A {Survey} of {Two} {Veriﬁable} {Delay} {Functions}},
	abstract = {A veriﬁable delay function (VDF) is an important tool used for adding delay in decentralized applications. This short note brieﬂy surveys and compares two recent beautiful Veriﬁable Delay Functions (VDFs), one due to Pietrzak and the other due to Wesolowski. We also provide a new computational proof of security for one of them, and compare the complexity assumptions needed for both schemes.},
	language = {en},
	author = {Boneh, Dan and Bunz, Benedikt and Fisch, Ben},
	pages = {13},
	annote = {Extracted Annotations (4/22/2020, 7:02:13 PM)
"A veriable delay function (VDF) is an important tool used for adding delay in decentralized applications." (Boneh et al :13)},
	file = {Boneh et al. - A Survey of Two Veriﬁable Delay Functions.pdf:/home/jani/Zotero/storage/FT22SPTE/Boneh et al. - A Survey of Two Veriﬁable Delay Functions.pdf:application/pdf}
}

@techreport{wesolowski_efficient_2018,
	title = {Efficient verifiable delay functions},
	url = {http://eprint.iacr.org/2018/623},
	abstract = {We construct a verifiable delay function (VDF). A VDF is a function whose evaluation requires running a given number of sequential steps, yet the result can be efficiently verified. They have applications in decentralised systems, such as the generation of trustworthy public randomness in a trustless environment, or resource-efficient blockchains. To construct our VDF, we actually build a trapdoor VDF. A trapdoor VDF is essentially a VDF which can be evaluated efficiently by parties who know a secret (the trapdoor). By setting up this scheme in a way that the trapdoor is unknown (not even by the party running the setup, so that there is no need for a trusted setup environment), we obtain a simple VDF. Our construction is based on groups of unknown order such as an RSA group, or the class group of an imaginary quadratic field. The output of our construction is very short (the result and the proof of correctness are each a single element of the group), and the verification of correctness is very efficient.},
	number = {623},
	urldate = {2020-02-11},
	author = {Wesolowski, Benjamin},
	year = {2018},
	keywords = {cryptographic protocols, proof of sequential work, time-lock puzzle, class group of imaginary quadratic field, randomness beacon, RSA},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/ESDWPYMY/Wesolowski - 2018 - Efficient verifiable delay functions.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/JDYHNMJW/623.html:text/html}
}

@misc{noauthor_spacemesh_2019,
	title = {Spacemesh {Protocol} v1.0},
	url = {https://spacemesh.io/spacemesh-protocol-v1-0/},
	abstract = {We are very excited to share with you today, Sep 13th, 2019, an updated version of the Spacemesh protocol paper. We expect to release updated versions of the paper with additional details on an on-going basis. For now, we present to you - version 1.0!},
	language = {en},
	urldate = {2020-02-11},
	journal = {Spacemesh},
	month = sep,
	year = {2019},
	file = {Snapshot:/home/jani/Zotero/storage/9VAMI4NC/spacemesh-protocol-v1-0.html:text/html}
}

@misc{noauthor_spacemesh-protocol-eprint-v102pdf_nodate,
	title = {spacemesh-protocol-eprint-v1.0.2.pdf},
	url = {https://drive.google.com/file/d/18I9GPebWqgpvusI1kMnAB9nayBbL-1qN/view?usp=sharing&usp=embed_facebook},
	urldate = {2020-02-11},
	journal = {Google Docs},
	file = {Snapshot:/home/jani/Zotero/storage/6CK5V3Q5/view.html:text/html}
}

@techreport{pietrzak_simple_2018,
	title = {Simple {Verifiable} {Delay} {Functions}},
	url = {http://eprint.iacr.org/2018/627},
	abstract = {We construct a verifable delay function (VDF) by showing how the Rivest-Shamir-Wagner time-lock puzzle can be made publicly verifiable.



Concretely, we give a statistically sound public-coin protocol to prove that a tuple \$(N,x,T,y)\$ satisfies \$y=x{\textasciicircum}\{2{\textasciicircum}T\}{\textbackslash}pmod N\$ where the prover doesn't know the factorization of \$N\$ and its running time is dominated by solving the puzzle, that is, compute \$x{\textasciicircum}\{2{\textasciicircum}T\}\$, which is conjectured to require \$T\$ sequential squarings. To get a VDF we make this protocol non-interactive using the Fiat-Shamir heuristic.

The motivation for this work comes from the Chia blockchain design, which uses a VDF as a key ingredient. For typical parameters (\$T{\textbackslash}le 2{\textasciicircum}\{40\},N=2048\$), our proofs are of size around \$10KB\$, verification cost around three RSA exponentiations and computing the proof is \$8000\$ times faster than solving the puzzle even without any parallelism.},
	number = {627},
	urldate = {2020-02-11},
	author = {Pietrzak, Krzysztof},
	year = {2018},
	keywords = {RSA, foundations, Verifiable Delay Function},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/37DD8XXV/Pietrzak - 2018 - Simple Verifiable Delay Functions.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/58JKNYAQ/627.html:text/html}
}

@misc{noauthor_vdf_nodate,
	title = {{VDF} {Research}},
	url = {https://vdfresearch.org/},
	urldate = {2020-02-11},
	file = {VDF Research:/home/jani/Zotero/storage/L3X8PQDU/vdfresearch.org.html:text/html}
}

@techreport{mahmoody_note_2019,
	title = {A {Note} on the ({Im})possibility of {Verifiable} {Delay} {Functions} in the {Random} {Oracle} {Model}},
	url = {http://eprint.iacr.org/2019/663},
	abstract = {Boneh, Bonneau, Bünz, and Fisch (CRYPTO 2018) recently introduced the notion of a verifiable delay function (VDF). VDFs are functions that take a long sequential time \$T\$ to compute, but whose outputs \$y {\textbackslash}get {\textbackslash}mathrm\{Eval\}(x)\$ can be efficiently verified (possibly given a proof \${\textbackslash}pi\$) in time \$t {\textbackslash}ll T\$ (e.g., \$t={\textbackslash}mathrm\{poly\}({\textbackslash}lambda, {\textbackslash}log T)\$ where \${\textbackslash}lambda\$ is the security parameter). The first security requirement on a VDF is that no polynomial-time algorithm can find a convincing proof \${\textbackslash}pi'\$ that verifies for an input \$x\$ and a different output \$y' {\textbackslash}neq y\$. The second security requirement is that that no polynomial-time algorithm running in sequential time \$T'{\textless}T\$ (e.g., \$T'=T{\textasciicircum}\{1/10\}\$) can compute \$y\$. Starting from the work of Boneh et al., there are now multiple constructions of VDFs from various algebraic assumptions.



In this work, we study whether VDFs can be constructed from ideal hash functions as modeled in the random oracle model (ROM). In the ROM, we measure the running time by the number of oracle queries and the sequentiality by the number of rounds of oracle queries. We show that VDFs satisfying perfect uniqueness (i.e., VDFs where no algorithm can find a convincing different solution \$y' {\textbackslash}neq y\$) cannot be constructed in the ROM. More formally, we give an attacker that finds the solution \$y\$ in \${\textbackslash}approx t\$ rounds of queries and asking only \${\textbackslash}mathrm\{poly\}(T)\$ queries in total. In addition, we show that a simple adaptation of our techniques can be used to rule out tight proofs of sequential work (proofs of sequential work are essentially VDFs without the uniqueness property).},
	number = {663},
	urldate = {2020-02-11},
	author = {Mahmoody, Mohammad and Smith, Caleb and Wu, David J.},
	year = {2019},
	keywords = {foundations, Proofs of Sequential Work, Random Oracle Model, Verifiable Delay Functions},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/HCGBQRUX/Mahmoody et al. - 2019 - A Note on the (Im)possibility of Verifiable Delay .pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/4ZDLBQGR/663.html:text/html}
}

@inproceedings{chajed_verifying_2019,
	address = {Huntsville, Ontario, Canada},
	title = {Verifying concurrent, crash-safe systems with {Perennial}},
	isbn = {978-1-4503-6873-5},
	url = {http://dl.acm.org/citation.cfm?doid=3341301.3359632},
	doi = {10.1145/3341301.3359632},
	abstract = {This paper introduces Perennial, a framework for verifying concurrent, crash-safe systems. Perennial extends the Iris concurrency framework with three techniques to enable crash-safety reasoning: recovery leases, recovery helping, and versioned memory. To ease development and deployment of applications, Perennial provides Goose, a subset of Go and a translator from that subset to a model in Perennial with support for reasoning about Go threads, data structures, and file-system primitives. We implemented and verified a crash-safe, concurrent mail server using Perennial and Goose that achieves speedup on multiple cores. Both Perennial and Iris use the Coq proof assistant, and the mail server and the framework’s proofs are machine checked.},
	language = {en},
	urldate = {2020-02-12},
	booktitle = {Proceedings of the 27th {ACM} {Symposium} on {Operating} {Systems} {Principles} - {SOSP} '19},
	publisher = {ACM Press},
	author = {Chajed, Tej and Tassarotti, Joseph and Kaashoek, M. Frans and Zeldovich, Nickolai},
	year = {2019},
	pages = {243--258},
	file = {Chajed et al. - 2019 - Verifying concurrent, crash-safe systems with Pere.pdf:/home/jani/Zotero/storage/3SZRH979/Chajed et al. - 2019 - Verifying concurrent, crash-safe systems with Pere.pdf:application/pdf}
}

@misc{murat_metadata_2014,
	title = {Metadata: {Hybrid} {Logical} {Clocks}},
	shorttitle = {Metadata},
	url = {https://muratbuffalo.blogspot.com/2014/07/hybrid-logical-clocks.html},
	urldate = {2020-02-16},
	journal = {Metadata},
	author = {Murat},
	month = jul,
	year = {2014},
	file = {Blogspot Snapshot:/home/jani/Zotero/storage/56V4IKVX/hybrid-logical-clocks.html:text/html}
}

@misc{murat_metadata_2013,
	title = {Metadata: {Spanner}: {Google}'s {Globally}-{Distributed} {Database}},
	shorttitle = {Metadata},
	url = {https://muratbuffalo.blogspot.com/2013/07/spanner-googles-globally-distributed_4.html},
	urldate = {2020-02-16},
	journal = {Metadata},
	author = {Murat},
	month = jul,
	year = {2013},
	file = {Blogspot Snapshot:/home/jani/Zotero/storage/QHV7C5GV/spanner-googles-globally-distributed_4.html:text/html}
}

@techreport{ephraim_continuous_2019,
	title = {Continuous {Verifiable} {Delay} {Functions}},
	url = {https://eprint.iacr.org/2019/619},
	abstract = {We introduce the notion of a(cVDF): a functionwhich is (a) iteratively sequential---meaning that evaluating the iterationof(on a random input) takes time roughlytimes the time to evaluate, even with many parallel processors, and (b) (iteratively) verifiable---the output ofcan be efficiently verified (in time that is essentially independent of). In other words, the iterated functionis a verifiable delay function (VDF) (Boneh et al., EUROCRYPT '19), having the property that intermediate steps of the computation (i.e.,for) are publicly and continuously verifiable.},
	number = {619},
	urldate = {2020-02-19},
	author = {Ephraim, Naomi and Freitag, Cody and Komargodski, Ilan and Pass, Rafael},
	year = {2019},
	keywords = {foundations, continuous verifiability, PPAD hardness, randomness beacons, Verifiable delay functions},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/84PY6E84/Ephraim et al. - 2019 - Continuous Verifiable Delay Functions.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/3JWGXXRH/619.html:text/html}
}

@inproceedings{goldschlag_publicly_1998,
	title = {Publicly {Verifiable} {Lotteries}: {Applications} of {Delaying} {Functions}},
	shorttitle = {Publicly {Verifiable} {Lotteries}},
	abstract = {This paper uses delaying functions, functions that require significant calculation time, in the development of a one-pass lottery scheme in which winners are chosen fairly using only internal information. Since all this information may be published (even before the lottery closes), anyone can do the calculation and therefore verify that the winner was chosen correctly. Since the calculation uses a delaying function, ticket purchasers cannot take advantage of this information. Fraud on the part of the lottery agent is detectable and no single ticket purchaser needs to be trusted. Coalitions of purchasers attempting to control the winning ticket calculation are either unsuccessful or are detected. The scheme can be made resistant to coalitions of arbitrary size. Since we assume that coalitions of larger size are harder to assemble, the probability that the lottery is fair can be made arbitrarily high. The paper defines delaying functions and contrasts them with pricing functions [8] and ...},
	booktitle = {In {Financial} {Crypto} ’98, {LNCS} 1465},
	publisher = {Springer-Verlag},
	author = {Goldschlag, David M. and Stubblebine, Stuart G.},
	year = {1998},
	pages = {214--226}
}

@misc{noauthor_minimal_2018,
	title = {Minimal {VDF} randomness beacon},
	url = {https://ethresear.ch/t/minimal-vdf-randomness-beacon/3566},
	abstract = {TLDR: We present a minimal randomness beacon using a Verifiable Delay Function (VDF). We argue for the safety and liveness of the RANDAO + VDF scheme and conclude with some discussion points.  Thanks to @prateek and @mihailobjelic for feedback.  Construction Assume a global clock and split time into contiguous 8-second blocks and 128-slot epochs. Each epoch i produces 32 bytes of (biasable) entropy e\_i to which correspond 32 bytes of (unbiasable) randomness r\_i. In a recursive fashion, the beaco...},
	language = {en-US},
	urldate = {2020-02-19},
	journal = {Ethereum Research},
	month = sep,
	year = {2018},
	file = {Snapshot:/home/jani/Zotero/storage/FLSWUBX9/3566.html:text/html}
}

@misc{noauthor_observations_2019,
	title = {Some {Observations} on {Eth2}.0 {Validators} and {Super}-{Full} {Node}},
	url = {https://ethresear.ch/t/some-observations-on-eth2-0-validators-and-super-full-node/6241},
	abstract = {Definitions:    Eth2.0 Validators: The block producers (BPs) in Eth2.0 are validators that are randomly selected from a validator pool, and each validator is assigned to one shard.  Given the initial number of shards M = 1024, we may require V {\textgreater} 100 validators in the network to achieve the desired security level (Security Level of Random Sampling With Sharding).  Super-Full Node: A super-full node processes the ledgers of all shards, and may be able to produce a block in any shard (as long as th...},
	language = {en-US},
	urldate = {2020-02-19},
	journal = {Ethereum Research},
	month = oct,
	year = {2019},
	file = {Snapshot:/home/jani/Zotero/storage/UBU4CBHR/6241.html:text/html}
}

@misc{noauthor_ethereumeips_nodate,
	title = {ethereum/{EIPs}},
	url = {https://github.com/ethereum/EIPs},
	abstract = {The Ethereum Improvement Proposal repository. Contribute to ethereum/EIPs development by creating an account on GitHub.},
	language = {en},
	urldate = {2020-02-19},
	journal = {GitHub},
	file = {Snapshot:/home/jani/Zotero/storage/W3Q7M2J4/eip-1011.html:text/html}
}

@misc{noauthor_shasper_2018,
	title = {Shasper viz 0.4},
	url = {https://observablehq.com/@cdetrio/shasper-viz-0-4},
	abstract = {An Observable notebook by cdetrio.},
	language = {en},
	urldate = {2020-02-19},
	month = sep,
	year = {2018},
	file = {Snapshot:/home/jani/Zotero/storage/YG4XDXR8/shasper-viz-0-4.html:text/html}
}

@techreport{cohen_simple_2018,
	title = {Simple {Proofs} of {Sequential} {Work}},
	url = {https://eprint.iacr.org/2018/183},
	abstract = {At ITCS 2013, Mahmoody, Moran and Vadhan [MMV'13] introduce and construct publicly verifiable proofs of sequential work, which is a protocol for proving that one spent sequential computational work related to some statement. The original motivation for such proofs included non-interactive time-stamping and universally verifiable CPU benchmarks. A more recent application, and our main motivation, are blockchain designs, where proofs of sequential work can be used -- in combination with proofs of space -- as a more ecological and economical substitute for proofs of work which are currently used to secure Bitcoin and other cryptocurrencies.



The construction proposed by [MMV'13] is based on a hash function and can be proven secure in the random oracle model, or assuming inherently sequential hash-functions, which is a new standard model assumption introduced in their work.

An open problem stated by [MMV'13] that our construction does not solve either is achieving a "unique" proof, where even a cheating prover can only generate a single accepting proof. This property would be extremely useful for applications to blockchains.},
	number = {183},
	urldate = {2020-02-19},
	author = {Cohen, Bram and Pietrzak, Krzysztof},
	year = {2018},
	keywords = {cryptographic protocols, Proofs of Sequential Work, Blockchain},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/WM26LXCT/Cohen and Pietrzak - 2018 - Simple Proofs of Sequential Work.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/VTVP7CAU/183.html:text/html}
}

@misc{noauthor_starks_nodate,
	title = {{STARKs}, {Part} 3: {Into} the {Weeds}},
	url = {https://vitalik.ca/general/2018/07/21/starks_part_3.html},
	urldate = {2020-02-19},
	file = {STARKs, Part 3\: Into the Weeds:/home/jani/Zotero/storage/CKVFM5CP/starks_part_3.html:text/html}
}

@techreport{boneh_single_2020,
	title = {Single {Secret} {Leader} {Election}},
	url = {http://eprint.iacr.org/2020/025},
	abstract = {In a Single Secret Leader Election (SSLE), a group of participants aim to randomly choose exactly one leader from the group with the restriction that the identity of the leader will be known to the chosen leader and nobody else. At a later time, the elected leader should be able to publicly reveal her identity and prove that she has won the election. The election process itself should work properly even if many registered users are passive and do not send any messages. Among the many applications of SSLEs, their potential for enabling more efficient proof-of-stake based cryptocurrencies have recently received increased attention.



This paper formally defines SSLE schemes and presents three constructions that provide varying security and performance properties. First, as an existence argument, we show how to realize an ideal SSLE using indistinguishability obfuscation. Next, we show how to build SSLE from low-depth threshold fully homomorphic encryption (TFHE) via a construction which can be instantiated with a circuit of multiplicative depth as low as 10, for realistically-sized secret leader elections. Finally, we show a practical scheme relying on DDH that achieves a slightly relaxed notion of security but which boasts extremely lightweight computational requirements.},
	number = {025},
	urldate = {2020-02-19},
	author = {Boneh, Dan and Eskandarian, Saba and Hanzlik, Lucjan and Greco, Nicola},
	year = {2020},
	keywords = {cryptographic protocols, proof of stake, secret leader election},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/FMH36EC2/Boneh et al. - 2020 - Single Secret Leader Election.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/PLKFWGCI/025.html:text/html}
}

@misc{noauthor_verifiable_2018,
	title = {Verifiable delay functions and attacks},
	url = {https://ethresear.ch/t/verifiable-delay-functions-and-attacks/2365/5},
	abstract = {Is the difficulty adjustment algorithm in VDF different than the one in PoW? I imagine it should not be since in VDF scheme everyone submits instead of only the fastest one as in PoW.  If we use PoW difficulty adjustment algorithm in VDF(i.e., to limit the fastest participant), participants would start to fail to reveal in time as attackers push up the difficulty and I suppose this is observable hence we could act on this in time to prevent the difficulty from climbing up?},
	language = {en-US},
	urldate = {2020-02-19},
	journal = {Ethereum Research},
	month = jul,
	year = {2018},
	file = {Snapshot:/home/jani/Zotero/storage/TDAX5DLF/5.html:text/html}
}

@misc{noauthor_vdf-based_2018,
	title = {{VDF}-based {RNG} with linear lookahead},
	url = {https://ethresear.ch/t/vdf-based-rng-with-linear-lookahead/2573},
	abstract = {TLDR: We present a VDF difficulty scheme that significantly reduces the RNG lookahead, i.e. the amount of time random numbers are made public before they are used.  Context  In a previous post Vitalik exposed a DoS attack on a naive VDF-based RNG where an attacker, assumed to have a hardware advantage up to A\_\{max\}, can ramp up the VDF difficulty and then under-perform (e.g. by going offline). This would cause the randomness beacon to pause for an extended period of time, hence stalling the beac...},
	language = {en-US},
	urldate = {2020-02-19},
	journal = {Ethereum Research},
	month = jul,
	year = {2018},
	file = {Snapshot:/home/jani/Zotero/storage/72I2RFKU/2573.html:text/html}
}

@article{rajab_feasibility_2020,
	title = {On the {Feasibility} of {Sybil} {Attacks} in {Shard}-{Based} {Permissionless} {Blockchains}},
	url = {http://arxiv.org/abs/2002.06531},
	abstract = {Bitcoin's single leader consensus protocol (Nakamoto consensus) suffers from significant transaction throughput and network scalability issues due to the computational requirements of it Proof-of-Work (PoW) based leader selection strategy. To overcome this, committee-based approaches (e.g., Elastico) that partition the outstanding transaction set into shards and (randomly) select multiple committees to process these transactions in parallel have been proposed and have become very popular. However, by design these committee or shard-based blockchain solutions are easily vulnerable to the Sybil attacks, where an adversary can easily compromise/manipulate the consensus protocol if it has enough computational power to generate multiple Sybil committee members (by generating multiple valid node identifiers). Despite the straightforward nature of these attacks, they have not been systematically analyzed. In this paper, we fill this research gap by modelling and analyzing Sybil attacks in a representative and popular shard-based protocol called Elastico. We show that the PoW technique used for identifier or ID generation in the initial phase of the protocol is vulnerable to Sybil attacks, and a node with high hash-power can generate enough Sybil IDs to successfully compromise Elastico. We analytically derive conditions for two different categories of Sybil attacks and perform numerical simulations to validate our theoretical results under different network and protocol parameters.},
	urldate = {2020-02-19},
	journal = {arXiv:2002.06531 [cs]},
	author = {Rajab, Tayebeh and Manshaei, Mohammad Hossein and Dakhilalian, Mohammad and Jadliwala, Murtuza and Rahman, Mohammad Ashiqur},
	month = feb,
	year = {2020},
	note = {arXiv: 2002.06531},
	keywords = {Computer Science - Cryptography and Security},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/223JWHNV/Rajab et al. - 2020 - On the Feasibility of Sybil Attacks in Shard-Based.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/9D6UGWDW/2002.html:text/html}
}

@article{ruan_blockchains_2019,
	title = {Blockchains and {Distributed} {Databases}: a {Twin} {Study}},
	shorttitle = {Blockchains and {Distributed} {Databases}},
	url = {http://arxiv.org/abs/1910.01310},
	abstract = {Blockchain has come a long way: a system that was initially proposed specifically for cryptocurrencies is now being adapted and adopted as a general-purpose transactional system. A blockchain is also a distributed system, and as such it shares some similarities with distributed database systems. Existing works that compare blockchains and distributed database systems focus mainly on high-level properties, such as security and throughput. They stop short of showing how the underlying design choices contribute to the overall differences. Our paper is to fill this important gap. In this paper, we perform a twin study of blockchains and distributed database systems as two types of transactional systems. We propose a taxonomy that helps illustrate their similarities and differences. In particular, we compare the systems along four dimensions: replication, concurrency, storage, and sharding. We discuss how the design choices have been driven by the system's goals: blockchain's goal is security, whereas the distributed database's goal is performance. We then conduct an extensive and in-depth performance study on two blockchains, namely Quorum and Hyperledger Fabric, and three distributed databases, namely CockroachDB, TiDB and etcd. We demonstrate how the different design choices in the four dimensions lead to different performance. In addition, we show that for most workloads, blockchain's performance is still lagging far behind that of a distributed database. However, the gap is not as significant as previously reported, and under high contention or constrained workloads, blockchains and databases are even comparable. Our work provides a framework for exploring the design space of hybrid database-blockchain systems.},
	urldate = {2020-02-19},
	journal = {arXiv:1910.01310 [cs]},
	author = {Ruan, Pingcheng and Chen, Gang and Dinh, Tien Tuan Anh and Lin, Qian and Loghin, Dumitrel and Ooi, Beng Chin and Zhang, Meihui},
	month = oct,
	year = {2019},
	note = {arXiv: 1910.01310},
	keywords = {Computer Science - Databases, Computer Science - Performance},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/UMBUIV6V/Ruan et al. - 2019 - Blockchains and Distributed Databases a Twin Stud.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/X89NE2EP/1910.html:text/html}
}

@article{amiri_sharper_2020,
	title = {{SharPer}: {Sharding} {Permissioned} {Blockchains} {Over} {Network} {Clusters}},
	shorttitle = {{SharPer}},
	url = {http://arxiv.org/abs/1910.00765},
	abstract = {Scalability is one of the main roadblocks to business adoption of blockchain systems. Despite recent intensive research on using sharding techniques to enhance the scalability of blockchain systems, existing solutions do not efficiently address cross-shard transactions. In this paper, we introduce SharPer, a permissioned blockchain system that improves scalability by clustering (partitioning) the nodes and assigning different data shards to different clusters where each data shard is replicated on the nodes of a cluster. SharPer supports both intra-shard and cross-shard transactions and processes intra-shard transactions of different clusters as well as cross-shard transactions with non-overlapping clusters simultaneously. In SharPer, the blockchain ledger is formed as a directed acyclic graph where each cluster maintains only a view of the ledger. SharPer also incorporates a flattened protocol to establish consensus among clusters on the order of cross-shard transactions. The experimental results reveal the efficiency of SharPer in terms of performance and scalability especially in workloads with a low percentage of cross-shard transactions.},
	urldate = {2020-02-19},
	journal = {arXiv:1910.00765 [cs]},
	author = {Amiri, Mohammad Javad and Agrawal, Divyakant and Abbadi, Amr El},
	month = feb,
	year = {2020},
	note = {arXiv: 1910.00765},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing, Computer Science - Databases},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/P7KNNGI2/Amiri et al. - 2020 - SharPer Sharding Permissioned Blockchains Over Ne.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/7GQEGYIP/1910.html:text/html}
}

@article{durand_stakecube_2019,
	title = {{StakeCube}: {Combining} {Sharding} and {Proof}-of-{Stake} to build {Fork}-free {Secure} {Permissionless} {Distributed} {Ledgers}},
	shorttitle = {{StakeCube}},
	url = {http://arxiv.org/abs/1907.05314},
	abstract = {Our work focuses on the design of a scalable permissionless blockchain in the proof-of-stake setting. In particular, we use a distributed hash table as a building block to set up randomized shards, and then leverage the sharded architecture to validate blocks in an efficient manner. We combine verifiable Byzantine agreements run by shards of stakeholders and a block validation protocol to guarantee that forks occur with negligible probability. We impose induced churn to make shards robust to eclipse attacks, and we rely on the UTXO coin model to guarantee that any stakeholder action is securely verifiable by anyone. Our protocol works against adaptive adversary, and makes no synchrony assumption beyond what is required for the byzantine agreement.},
	urldate = {2020-02-19},
	journal = {arXiv:1907.05314 [cs]},
	author = {Durand, Antoine and Anceaume, Emmanuelle and Ludinard, Romaric},
	month = jul,
	year = {2019},
	note = {arXiv: 1907.05314},
	keywords = {Computer Science - Cryptography and Security, Computer Science - Distributed, Parallel, and Cluster Computing},
	annote = {Comment: Preprint, 16 pages, to appear in Proceedings of The 7th Edition of The International Conference on NETworked sYStems (NETYS2019)},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/3RP2Q29H/Durand et al. - 2019 - StakeCube Combining Sharding and Proof-of-Stake t.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/BNJ6T354/1907.html:text/html}
}

@article{cui_blockchain_2019,
	title = {Blockchain in {IoT}: {Current} {Trends}, {Challenges}, and {Future} {Roadmap}},
	volume = {3},
	issn = {2509-3436},
	shorttitle = {Blockchain in {IoT}},
	url = {https://doi.org/10.1007/s41635-019-00079-5},
	doi = {10.1007/s41635-019-00079-5},
	abstract = {The Internet of Things (IoT) is one of the most promising technologies in the era of information technology. IoT enables ubiquitous data collections and network communications to bring significant and indispensable convenience and intelligence both to daily life and industrial operations. However, IoT is still confronting a number of challenges and manifesting a series of issues that need to be addressed urgently. Counterfeit hardware, software faults, security issues during communication, system management difficulties, and data privacy issues are significant issues for current IoT infrastructure. Meanwhile, blockchain, as an emerging information technology, has attracted huge public interest and has shown significant promise because of its decentralization, transparency, and security. The features of blockchain seem to be an ideal match for IoT, and by applying blockchain to an IoT environment, some of the aforementioned weaknesses can be addressed. This paper’s purpose is to introduce the use of blockchain in IoT applications. We present various challenges facing an IoT system and summarize the benefits of adopting blockchain into IoT infrastructure. We primarily focus on illustrating the blockchain applications in IoT with refined capabilities and enhanced security. To shed light on blockchain in IoT research, we also discuss limitations and future directions.},
	language = {en},
	number = {4},
	urldate = {2020-02-19},
	journal = {Journal of Hardware and Systems Security},
	author = {Cui, Pinchen and Guin, Ujjwal and Skjellum, Anthony and Umphress, David},
	month = dec,
	year = {2019},
	pages = {338--364},
	file = {Springer Full Text PDF:/home/jani/Zotero/storage/KQ25TKVX/Cui et al. - 2019 - Blockchain in IoT Current Trends, Challenges, and.pdf:application/pdf}
}

@article{yu_low_2019,
	title = {Low powered blockchain consensus protocols based on consistent hash},
	volume = {20},
	issn = {2095-9230},
	url = {https://doi.org/10.1631/FITEE.1800119},
	doi = {10.1631/FITEE.1800119},
	abstract = {Current blockchain consensus protocols have a triangle of contradictions in aspects of decentralization, security, and energy consumption, and cannot be synchronously optimized. We describe a design of two new blockchain consensus protocols, called “CHB-consensus” and “CHBD-consensus,” based on a consistent hash algorithm. Honest miners can fairly gain the opportunity to create blocks. They do not consume any extra computational power resources when creating new blocks, and such blocks can obtain the whole blockchain network to confirm consensus with fairness. However, malicious miners have to pay massive computational power resources for attacking the new block creation privilege or double-spending. Blockchain networks formed by CHB-consensus and CHBD-consensus are based on the same security assumption as that in Bitcoin systems, so they save a huge amount of power without sacrificing decentralization or security. We analyze possible attacks and give a rigorous but adjustable validation strategy. CHB-consensus and CHBD-consensus introduce a certification authority (CA) system, which does not have special management or control rights over blockchain networks or data structures, but carries the risk of privacy breaches depending on credibility and reliability of the CA system. Here, we analyze the robustness and energy consumption of CHB-consensus and CHBD-consensus, and demonstrate their advantages through theoretical derivation.},
	language = {en},
	number = {10},
	urldate = {2020-02-19},
	journal = {Frontiers of Information Technology \& Electronic Engineering},
	author = {Yu, Lei and Zhao, Xiao-fang and Jin, Yan and Cai, Heng-yi and Wei, Bo and Hu, Bin},
	month = oct,
	year = {2019},
	pages = {1361--1377},
	file = {Springer Full Text PDF:/home/jani/Zotero/storage/VUJTC8P2/Yu et al. - 2019 - Low powered blockchain consensus protocols based o.pdf:application/pdf}
}

@article{chen_sschain_2019,
	title = {{SSChain}: {A} full sharding protocol for public blockchain without data migration overhead},
	volume = {59},
	issn = {1574-1192},
	shorttitle = {{SSChain}},
	url = {http://www.sciencedirect.com/science/article/pii/S1574119218306370},
	doi = {10.1016/j.pmcj.2019.101055},
	abstract = {Blockchain, known as distributed ledger technology, suffers from the scalability problem. A major approach to overcoming this limitation is using sharding, which divides the network into multiple smaller groups, called shards, these shards can work in parallel on disjoint transactions and maintain disjoint ledgers. Existing sharding-based protocols rely on reshuffling scheme to maintain security, however, since each shard only maintains a disjoint ledger, reshuffling the network will cause huge data migration. In this work, we propose SSChain, a novel non-reshuffling structure that supports both transaction sharding and state sharding. Our empirical evaluations suggest that SSChain can process more than 6,500 TPS in a network of 1,800 nodes without any data migration overhead.},
	language = {en},
	urldate = {2020-02-19},
	journal = {Pervasive and Mobile Computing},
	author = {Chen, Huan and Wang, Yijie},
	month = oct,
	year = {2019},
	keywords = {Blockchain, Scalability, State sharding, Transaction sharding},
	pages = {101055},
	file = {ScienceDirect Full Text PDF:/home/jani/Zotero/storage/GMV6QN4C/Chen and Wang - 2019 - SSChain A full sharding protocol for public block.pdf:application/pdf;ScienceDirect Snapshot:/home/jani/Zotero/storage/JUAYR2R2/S1574119218306370.html:text/html}
}

@inproceedings{bugday_securing_2019,
	title = {Securing {Blockchain} {Shards} {By} {Using} {Learning} {Based} {Reputation} and {Verifiable} {Random} {Functions}},
	doi = {10.1109/ISNCC.2019.8909175},
	abstract = {In order to meet the increasing demand of the blockchain, it needs to find a solution to the scalability problem. It has been focused on sharding recently to address the scalability problem. In the sharding method, the blockchain is divided into pieces. Instead of a more extensive network, networks with fewer nodes are created. As a result, it becomes more important that each node in the network is reliable. In this study, studies using sharding method have been investigated, and methods for the assigning nodes to shards are proposed. The use of learning-based adaptive methods for this process will contribute to the safe and reliable use of shards. The probability of the shards to deteriorate and influence the whole blockchain will be reduced.},
	booktitle = {2019 {International} {Symposium} on {Networks}, {Computers} and {Communications} ({ISNCC})},
	author = {Bugday, Ahmet and Ozsoy, Adnan and Sever, Hayri},
	month = jun,
	year = {2019},
	note = {ISSN: null},
	keywords = {Blockchain, Scalability, Bitcoin, blockchain network, Blockchain shards, cryptography, Databases, extensive network, learning (artificial intelligence), learning based reputation, learning-based adaptive methods, node reputation, peer-to-peer computing, probability, random functions, Reliability, scalability, scalability problem, sharding, sharding method, verifiable random functions},
	pages = {1--4},
	file = {IEEE Xplore Abstract Record:/home/jani/Zotero/storage/MQZRLVJR/8909175.html:text/html;IEEE Xplore Full Text PDF:/home/jani/Zotero/storage/5LVI6PHP/Bugday et al. - 2019 - Securing Blockchain Shards By Using Learning Based.pdf:application/pdf}
}

@inproceedings{kokoris-kogias_omniledger_2018,
	title = {{OmniLedger}: {A} {Secure}, {Scale}-{Out}, {Decentralized} {Ledger} via {Sharding}},
	shorttitle = {{OmniLedger}},
	doi = {10.1109/SP.2018.000-5},
	abstract = {Designing a secure permissionless distributed ledger (blockchain) that performs on par with centralized payment processors, such as Visa, is a challenging task. Most existing distributed ledgers are unable to scale-out, i.e., to grow their total processing capacity with the number of validators; and those that do, compromise security or decentralization. We present OmniLedger, a novel scale-out distributed ledger that preserves longterm security under permissionless operation. It ensures security and correctness by using a bias-resistant public-randomness protocol for choosing large, statistically representative shards that process transactions, and by introducing an efficient cross-shard commit protocol that atomically handles transactions affecting multiple shards. OmniLedger also optimizes performance via parallel intra-shard transaction processing, ledger pruning via collectively-signed state blocks, and low-latency "trust-but-verify" validation for low-value transactions. An evaluation of our experimental prototype shows that OmniLedger's throughput scales linearly in the number of active validators, supporting Visa-level workloads and beyond, while confirming typical transactions in under two seconds.},
	booktitle = {2018 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	author = {Kokoris-Kogias, Eleftherios and Jovanovic, Philipp and Gasser, Linus and Gailly, Nicolas and Syta, Ewa and Ford, Bryan},
	month = may,
	year = {2018},
	note = {ISSN: 2375-1207},
	keywords = {data privacy, Scalability, Bitcoin, sharding, Atomix, bias-resistant public-randomness protocol, blockchain, Byzantine Fault Tolerant, ByzCoinX, centralized payment processors, collectively-signed state blocks, compromise security, cross shard, cross-shard commit protocol, decentralization, decentralized ledger, distributed ledger, ledger pruning, OmniLedger, parallel intra-shard transaction processing, process transactions, protocols, Protocols, randomness, scalable, scale-out distributed ledger, secure permissionless distributed ledger, state blocks, statistical analysis, statistically representative shards, Throughput, total processing capacity, transaction processing, trust but verify},
	pages = {583--598},
	file = {IEEE Xplore Abstract Record:/home/jani/Zotero/storage/PFPALLT3/8418625.html:text/html;IEEE Xplore Full Text PDF:/home/jani/Zotero/storage/2BZLKSLJ/Kokoris-Kogias et al. - 2018 - OmniLedger A Secure, Scale-Out, Decentralized Led.pdf:application/pdf}
}

@article{yun_trust-based_2019,
	title = {Trust-{Based} {Shard} {Distribution} {Scheme} for {Fault}-{Tolerant} {Shard} {Blockchain} {Networks}},
	volume = {7},
	issn = {2169-3536},
	doi = {10.1109/ACCESS.2019.2942003},
	abstract = {Blockchains guarantee data integrity through consensus of distributed ledgers based on multiple validation nodes called miners. For this reason, any blockchain system can be critically disabled by a malicious attack from a majority of the nodes (e.g., 51\% attack). These attacks are more likely to succeed as the number of nodes required for consensus is smaller. Recently, as blockchains are becoming too large (making them difficult to store, send, receive, and manage), sharding is being considered as a technology to help improve the transaction throughput and scalability of blockchains. Sharding distributes block validators to disjoint sets to process transactions in parallel. Therefore, the number of validators of each shard group is smaller, which makes shard-based blockchains more vulnerable to 51\% attacks than blockchains that do not use sharding. To solve this problem, this paper proposes a trust-based shard distribution (TBSD) scheme that assigns potential malicious nodes in the network to different shards, preventing malicious nodes from gaining a dominating influence on the consensus of a single shard. TBSD uses a trust-based shard distribution scheme to prevent malicious miners from gathering in on one shard by integration of a trust management system and genetic algorithm (GA). First, the trust of all nodes is computed based on the previous consensus result. Then, a GA is used to compute the shard distribution set to prevent collusion of malicious miners. The performance evaluation shows that the proposed TBSD scheme results in a shard distribution with a higher level of fairness than existing schemes, which provides an improved level of protection against malicious attacks.},
	journal = {IEEE Access},
	author = {Yun, Jusik and Goh, Yunyeong and Chung, Jong-Moon},
	year = {2019},
	keywords = {distributed ledgers, trusted computing, Blockchain, Scalability, Bitcoin, cryptography, sharding, data integrity, data mining, distributed databases, fault tolerant, fault-tolerant shard blockchain networks, genetic algorithm, genetic algorithms, Genetic algorithms, malicious attack, malicious miners, parallel processing, parallel transaction processing, Peer-to-peer computing, Safety, shard-based blockchains, software fault tolerance, trust, Trust management, trust management system, trust-based shard distribution scheme},
	pages = {135164--135175},
	file = {IEEE Xplore Abstract Record:/home/jani/Zotero/storage/ELY9WNRB/8840847.html:text/html;IEEE Xplore Full Text PDF:/home/jani/Zotero/storage/SEB4V746/Yun et al. - 2019 - Trust-Based Shard Distribution Scheme for Fault-To.pdf:application/pdf}
}

@article{yi_diffusion_2020,
	title = {Diffusion and {Consensus} in a {Weakly} {Coupled} {Network} of {Networks}},
	url = {http://arxiv.org/abs/2002.06109},
	abstract = {We study diffusion and consensus dynamics in a Network of Networks model. In this model, there is a collection of sub-networks, connected to one another using a small number of links. We consider a setting where the links between networks have small weights, or are used less frequently than links within each sub-network. Using spectral perturbation theory, we analyze the diffusion rate and convergence rate of the investigated systems. Our analysis shows that the first order approximation of the diffusion and convergence rates is independent of the topologies of the individual graphs; the rates depend only on the number of nodes in each graph and the topology of the connecting edges. The second order analysis shows a relationship between the diffusion and convergence rates and the information centrality of the connecting nodes within each sub-network. We further highlight these theoretical results through numerical examples.},
	urldate = {2020-02-19},
	journal = {arXiv:2002.06109 [cs, eess]},
	author = {Yi, Yuhao and Das, Anirban and Patterson, Stacy and Bamieh, Bassam and Zhang, Zhongzhi},
	month = feb,
	year = {2020},
	note = {arXiv: 2002.06109},
	keywords = {Computer Science - Social and Information Networks, Electrical Engineering and Systems Science - Systems and Control},
	annote = {Comment: 12 pages, 5 figures},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/YQTKTDEN/Yi et al. - 2020 - Diffusion and Consensus in a Weakly Coupled Networ.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/T244B6Z8/2002.html:text/html}
}

@article{lampson_how_1996,
	title = {How to {Build} a {Highly} {Available} {System} {Using} {Consensus}},
	url = {https://www.microsoft.com/en-us/research/publication/how-to-build-a-highly-available-system-using-consensus/},
	abstract = {Lamport showed that a replicated deterministic state machine is a general way to implement a highly available system, given a consensus algo-rithm that the replicas can use to agree on each input. His Paxos algorithm is the most fault-tolerant way to get consensus without real-time guarantees. Because general consensus is expensive, practical systems reserve it …},
	language = {en-US},
	urldate = {2020-02-19},
	author = {Lampson, Butler},
	month = oct,
	year = {1996},
	file = {Snapshot:/home/jani/Zotero/storage/BRKA994A/how-to-build-a-highly-available-system-using-consensus.html:text/html}
}

@techreport{kiayias_ouroboros_2016,
	title = {Ouroboros: {A} {Provably} {Secure} {Proof}-of-{Stake} {Blockchain} {Protocol}},
	shorttitle = {Ouroboros},
	url = {http://eprint.iacr.org/2016/889},
	abstract = {We present ``Ouroboros,'' the first blockchain protocol based on proof of stake with rigorous security guarantees. We establish security properties for the protocol comparable to those achieved by the bitcoin blockchain protocol. As the protocol provides a ``proof of stake'' blockchain discipline, it offers qualitative efficiency advantages over blockchains based on proof of physical resources (e.g., proof of work). We also present a novel reward mechanism for incentivizing proof of stake protocols and we prove that, given this mechanism, honest behavior is an approximate Nash equilibrium, thus neutralizing attacks such as selfish mining. We also present initial evidence of the practicality of our protocol in real world settings by providing experimental results on transaction confirmation and processing.},
	number = {889},
	urldate = {2020-02-19},
	author = {Kiayias, Aggelos and Russell, Alexander and David, Bernardo and Oliynykov, Roman},
	year = {2016},
	keywords = {blockchain, consensus, proof of stake.},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/THU7PCQF/Kiayias et al. - 2016 - Ouroboros A Provably Secure Proof-of-Stake Blockc.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/H6M9JCBE/889.html:text/html}
}

@misc{noauthor_towards_nodate,
	title = {Towards {Scaling} {Blockchain} {Systems} via {Sharding} {\textbar} {Proceedings} of the 2019 {International} {Conference} on {Management} of {Data}},
	url = {http://dl.acm.org/doi/abs/10.1145/3299869.3319889},
	language = {EN},
	urldate = {2020-02-19},
	file = {Snapshot:/home/jani/Zotero/storage/PZKEUCRZ/login.html:text/html}
}

@inproceedings{ren_scale-out_2018,
	title = {A {Scale}-{Out} {Blockchain} for {Value} {Transfer} with {Spontaneous} {Sharding}},
	doi = {10.1109/CVCBT.2018.00006},
	abstract = {Bitcoin, as well as many of its successors, require the whole transaction record to be reliably acquired by all nodes to prevent double-spending. Recently, many blockchains have been proposed to achieve scale-out throughput by letting nodes only acquire a fraction of the whole transaction set. However, these schemes, e.g., sharding and off-chain techniques, suffer from a degradation in decentralization or the capacity of fault tolerance. In this paper, we show that the complete set of transactions is not a necessity for the prevention of double-spending if the properties of value transfers is fully explored. In other words, we show that a value-transfer ledger like Bitcoin has the potential to scale-out by its nature without sacrificing security or decentralization. Firstly, we give a formal definition for the value-transfer ledger and its distinct features from a generic database. Then, we introduce the blockchain structure with a shared main chain for consensus and an individual chain for each node for recording transactions. A locally executable validation scheme is proposed with uncompromising validity and consistency. A beneficial consequence of our design is that nodes will spontaneously try to reduce their transmission cost by only providing the transactions needed to show that their transactions are not double spend. As a result, the network is sharded as each node only acquires part of the transaction record and a scale-out throughput could be achieved, which we call "spontaneous sharding".},
	booktitle = {2018 {Crypto} {Valley} {Conference} on {Blockchain} {Technology} ({CVCBT})},
	author = {Ren, Zhijie and Cong, Kelong and Aerts, Taico and de Jonge, Bart and Morais, Alejandro and Erkin, Zekeriya},
	month = jun,
	year = {2018},
	note = {ISSN: null},
	keywords = {Blockchain, Scalability, Bitcoin, cryptography, Reliability, decentralization, Throughput, transaction processing, blockchain structure, blockchains, double-spending, electronic money, fault tolerance, formal definition, individual chain, locally executable validation scheme, Off chain, off-chain techniques, Receivers, Scale out, scale-out blockchain, scale-out throughput, Sharding, shared main chain, spontaneous sharding, transaction record, value transfer, value-transfer ledger},
	pages = {1--10},
	file = {IEEE Xplore Abstract Record:/home/jani/Zotero/storage/MJFE4IKM/8525387.html:text/html;IEEE Xplore Full Text PDF:/home/jani/Zotero/storage/2CBQHKNV/Ren et al. - 2018 - A Scale-Out Blockchain for Value Transfer with Spo.pdf:application/pdf}
}

@article{zhang_analysis_2019,
	title = {Analysis of the main consensus protocols of blockchain},
	issn = {2405-9595},
	url = {http://www.sciencedirect.com/science/article/pii/S240595951930164X},
	doi = {10.1016/j.icte.2019.08.001},
	abstract = {Blockchain is the core technology of many cryptocurrencies. Blockchain as a distributed ledger technology has received extensive research attention. In addition to cryptography and P2P (peer-to-peer) technology, consensus protocols are also a fundamental part of the blockchain technology. A good consensus protocol can guarantee the fault tolerance and security of the blockchain systems. The consensus protocols currently used in most blockchain systems can be broadly divided into two categories: the probabilistic-finality consensus protocols and the absolute-finality consensus protocols. This paper introduces some of the main consensus protocols of these two categories, and analyzes their strengths and weaknesses as well as the applicable blockchain types.},
	language = {en},
	urldate = {2020-02-20},
	journal = {ICT Express},
	author = {Zhang, Shijie and Lee, Jong-Hyouk},
	month = aug,
	year = {2019},
	keywords = {Blockchains, Consensus protocols, Cryptocurrencies},
	file = {ScienceDirect Full Text PDF:/home/jani/Zotero/storage/K5GVJ4Y9/Zhang and Lee - 2019 - Analysis of the main consensus protocols of blockc.pdf:application/pdf;ScienceDirect Snapshot:/home/jani/Zotero/storage/ZX6WMXEG/S240595951930164X.html:text/html}
}

@article{palmskog_verifying_nodate,
	title = {Verifying {Finality} for {Blockchain} {Systems}},
	language = {en},
	author = {Palmskog, Karl and Gligoric, Milos and Rosu, Lucas Peña Grigore},
	pages = {30},
	file = {Palmskog et al. - Verifying Finality for Blockchain Systems.pdf:/home/jani/Zotero/storage/HJ3ZW6I3/Palmskog et al. - Verifying Finality for Blockchain Systems.pdf:application/pdf}
}

@article{xiao_survey_2020,
	title = {A {Survey} of {Distributed} {Consensus} {Protocols} for {Blockchain} {Networks}},
	url = {http://arxiv.org/abs/1904.04098},
	abstract = {Since the inception of Bitcoin, cryptocurrencies and the underlying blockchain technology have attracted an increasing interest from both academia and industry. Among various core components, consensus protocol is the defining technology behind the security and performance of blockchain. From incremental modifications of Nakamoto consensus protocol to innovative alternative consensus mechanisms, many consensus protocols have been proposed to improve the performance of the blockchain network itself or to accommodate other specific application needs. In this survey, we present a comprehensive review and analysis on the state-of-the-art blockchain consensus protocols. To facilitate the discussion of our analysis, we first introduce the key definitions and relevant results in the classic theory of fault tolerance which help to lay the foundation for further discussion. We identify five core components of a blockchain consensus protocol, namely, block proposal, block validation, information propagation, block finalization, and incentive mechanism. A wide spectrum of blockchain consensus protocols are then carefully reviewed accompanied by algorithmic abstractions and vulnerability analyses. The surveyed consensus protocols are analyzed using the five-component framework and compared with respect to different performance metrics. These analyses and comparisons provide us new insights in the fundamental differences of various proposals in terms of their suitable application scenarios, key assumptions, expected fault tolerance, scalability, drawbacks and trade-offs. We believe this survey will provide blockchain developers and researchers a comprehensive view on the state-of-the-art consensus protocols and facilitate the process of designing future protocols.},
	urldate = {2020-02-20},
	journal = {arXiv:1904.04098 [cs]},
	author = {Xiao, Yang and Zhang, Ning and Lou, Wenjing and Hou, Y. Thomas},
	month = jan,
	year = {2020},
	note = {arXiv: 1904.04098},
	keywords = {Computer Science - Cryptography and Security, Computer Science - Distributed, Parallel, and Cluster Computing},
	annote = {Comment: Accepted by the IEEE Communications Surveys and Tutorials for publication},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/EXVBE2TI/Xiao et al. - 2020 - A Survey of Distributed Consensus Protocols for Bl.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/KK7MNHW8/1904.html:text/html}
}

@misc{gauba_finality_2018,
	title = {Finality in {Blockchain} {Consensus}},
	url = {https://medium.com/mechanism-labs/finality-in-blockchain-consensus-d1f83c120a9a},
	abstract = {Today, with the swipe of a credit card, I purchased a delightful matcha green tea (shout out to Asha in Berkeley). Just moments after the…},
	language = {en},
	urldate = {2020-02-20},
	journal = {Medium},
	author = {Gauba, Alexis},
	month = aug,
	year = {2018},
	file = {Snapshot:/home/jani/Zotero/storage/PBHXVPU9/finality-in-blockchain-consensus-d1f83c120a9a.html:text/html}
}

@misc{noauthor_consensus_2018,
	title = {Consensus {Algorithms}: {The} {Root} {Of} {The} {Blockchain} {Technology}},
	shorttitle = {Consensus {Algorithms}},
	url = {https://101blockchains.com/consensus-algorithms-blockchain/},
	abstract = {A comprehensive guide on Consensus Algorithms, which includes a complete list of all consensus algorithms that runs blockchain technology. Take a look now!},
	language = {en-US},
	urldate = {2020-02-20},
	journal = {101 Blockchains},
	month = aug,
	year = {2018},
	annote = {PBFT: "If the nodes agree on a specific block, then it gets finalized. This is due to the fact that, all the authentic nodes communicate with each other at the same time and come to an understanding of the specific block."},
	file = {Snapshot:/home/jani/Zotero/storage/3DCEMEBP/consensus-algorithms-blockchain.html:text/html}
}

@misc{mearian_sharding_2019,
	title = {Sharding: {What} it is and why many blockchain protocols rely on it},
	shorttitle = {Sharding},
	url = {https://www.computerworld.com/article/3336187/sharding-what-it-is-and-why-so-many-blockchain-protocols-rely-on-it.html},
	abstract = {Sharding could be the key to allowing blockchains to scale, while maintaining the privacy and security features that make the distributed ledger technology so hot. But there are hurdles that need to be addressed.},
	language = {en},
	urldate = {2020-02-27},
	journal = {Computerworld},
	author = {Mearian, Lucas},
	month = jan,
	year = {2019},
	file = {Snapshot:/home/jani/Zotero/storage/D6JXLV4U/sharding-what-it-is-and-why-so-many-blockchain-protocols-rely-on-it.html:text/html}
}

@article{knirsch_implementing_2019,
	title = {Implementing a blockchain from scratch: why, how, and what we learned},
	volume = {2019},
	issn = {2510-523X},
	shorttitle = {Implementing a blockchain from scratch},
	url = {https://jis-eurasipjournals.springeropen.com/articles/10.1186/s13635-019-0085-3},
	doi = {10.1186/s13635-019-0085-3},
	abstract = {Blockchains are proposed for many application domains apart from financial transactions. While there are generic blockchains that can be molded for specific use cases, they often lack a lightweight and easy-to-customize implementation. In this paper, we introduce the core concepts of blockchain technology and investigate a real-world use case from the energy domain, where customers trade portions of their photovoltaic power plant via a blockchain. This does not only involve blockchain technology, but also requires user interaction. Therefore, a fully custom, private, and permissioned blockchain is implemented from scratch. We evaluate and motivate the need for blockchain technology within this use case, as well as the desired properties of the system. We then describe the implementation and the insights from our implementation in detail, serving as a guide for others and to show potential opportunities and pitfalls when implementing a blockchain from scratch.},
	language = {en},
	number = {1},
	urldate = {2020-02-27},
	journal = {EURASIP Journal on Information Security},
	author = {Knirsch, Fabian and Unterweger, Andreas and Engel, Dominik},
	month = dec,
	year = {2019},
	pages = {2},
	file = {Knirsch et al. - 2019 - Implementing a blockchain from scratch why, how, .pdf:/home/jani/Zotero/storage/J3TT2SIY/Knirsch et al. - 2019 - Implementing a blockchain from scratch why, how, .pdf:application/pdf}
}

@misc{link_verifiable_nodate,
	title = {On {Verifiable} {Delay} {Functions} - {How} to {Slow} {Burning} the {Planet} {Down} ({Verifiably})},
	url = {http://blog.intothesymmetry.com/2019/05/on-verifiable-delay-functions-how-to.html},
	abstract = {Update: you can find the Part II of this series here    In this blog post I am going to talk about some really cool cryptographic research ...},
	urldate = {2020-03-04},
	author = {link, Get and Facebook and Twitter and Pinterest and Email and Apps, Other},
	note = {Library Catalog: blog.intothesymmetry.com},
	file = {Snapshot:/home/jani/Zotero/storage/8VBV7XX8/on-verifiable-delay-functions-how-to.html:text/html}
}

@techreport{feo_verifiable_2019,
	title = {Verifiable {Delay} {Functions} from {Supersingular} {Isogenies} and {Pairings}},
	url = {http://eprint.iacr.org/2019/166},
	abstract = {We present two new Verifiable Delay Functions (VDF) based on assumptions from elliptic curve cryptography. We discuss both the advantages and some drawbacks of our constructions, we study their security and we demonstrate their practicality with a proof-of-concept implementation.},
	number = {166},
	urldate = {2020-03-04},
	author = {Feo, Luca De and Masson, Simon and Petit, Christophe and Sanso, Antonio},
	year = {2019},
	keywords = {cryptographic protocols, Verifiable Delay Function, Elliptic curves, Isogenies, Pairings},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/FUQYAEIM/Feo et al. - 2019 - Verifiable Delay Functions from Supersingular Isog.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/269RTLEF/166.html:text/html}
}

@misc{skidanov_proof--space-time_nodate,
	title = {Proof-of-{Space}-{Time} without {VDFs}},
	url = {https://commonwealth.im/near/proposal/discussion/367-proofofspacetime-without-vdfs},
	abstract = {NEAR Protocol},
	urldate = {2020-03-04},
	author = {Skidanov, Alex},
	note = {Library Catalog: commonwealth.im},
	file = {Snapshot:/home/jani/Zotero/storage/W5W6RAPQ/367-proofofspacetime-without-vdfs.html:text/html}
}

@misc{noauthor_near_2019,
	title = {{NEAR} {Randomness}},
	url = {https://nearprotocol.com/papers/randomness},
	language = {en-US},
	urldate = {2020-03-04},
	journal = {NEAR Protocol},
	month = nov,
	year = {2019},
	note = {Library Catalog: nearprotocol.com},
	file = {Snapshot:/home/jani/Zotero/storage/56CT4DLK/randomness.html:text/html}
}

@misc{noauthor_sharding_2019,
	title = {Sharding {Design}: {Nightshade}},
	shorttitle = {Sharding {Design}},
	url = {https://nearprotocol.com/papers/nightshade},
	language = {en-US},
	urldate = {2020-03-04},
	journal = {NEAR Protocol},
	month = nov,
	year = {2019},
	note = {Library Catalog: nearprotocol.com},
	file = {Snapshot:/home/jani/Zotero/storage/R8X3KGD3/nightshade.html:text/html}
}

@misc{noauthor_how_2020,
	title = {How do {Randomness} {Beacons} based on {Threshold} {Signatures} work?},
	url = {https://nearprotocol.com/blog/randomness-threshold-signatures},
	abstract = {Back in 2015 DFinity made the community extremely excited with their design of a randomness beacon that was leveraging BLS…},
	language = {en-US},
	urldate = {2020-03-04},
	journal = {NEAR Protocol},
	month = feb,
	year = {2020},
	note = {Library Catalog: nearprotocol.com
Section: Uncategorized},
	file = {Snapshot:/home/jani/Zotero/storage/JZX8QWHP/randomness-threshold-signatures.html:text/html}
}

@misc{noauthor_guide_nodate,
	title = {A {Guide} to 99\% {Fault} {Tolerant} {Consensus}},
	url = {https://vitalik.ca/general/2018/08/07/99_fault_tolerant.html},
	urldate = {2020-03-05},
	file = {A Guide to 99% Fault Tolerant Consensus:/home/jani/Zotero/storage/PXWHY668/99_fault_tolerant.html:text/html}
}

@misc{noauthor_timeliness_2020,
	title = {Timeliness detectors and 51\% attack recovery in blockchains},
	url = {https://ethresear.ch/t/timeliness-detectors-and-51-attack-recovery-in-blockchains/6925},
	abstract = {Summary I propose a construction, based on Lamport’s 99\% fault tolerant consensus ideas, that I call timeliness detectors. Timeliness detectors allows online clients (ie. clients, aka users, that are connected to other clients with latency {\textbackslash}le {\textbackslash}delta) to detect, with guarantees of correctness and agreement, whether or not blocks were published “on time”. In the event of a 51\% attack, this allows at least the subset of clients that are online to come to agreement over (i) whether or not a “suffic...},
	language = {en-US},
	urldate = {2020-03-05},
	journal = {Ethereum Research},
	month = feb,
	year = {2020},
	note = {Library Catalog: ethresear.ch},
	file = {Snapshot:/home/jani/Zotero/storage/B3KTDV2P/6925.html:text/html}
}

@misc{buterin_proof_2016,
	title = {A {Proof} of {Stake} {Design} {Philosophy}},
	url = {https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51},
	abstract = {Systems like Ethereum (and Bitcoin, and NXT, and Bitshares, etc) are a fundamentally new class of cryptoeconomic organisms — decentralized…},
	language = {en},
	urldate = {2020-03-05},
	journal = {Medium},
	author = {Buterin, Vitalik},
	month = dec,
	year = {2016},
	note = {Library Catalog: medium.com},
	file = {Snapshot:/home/jani/Zotero/storage/GLD5FJQ9/a-proof-of-stake-design-philosophy-506585978d51.html:text/html}
}

@misc{noauthor_preimage_2019,
	title = {Preimage attack},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Preimage_attack&oldid=902805697},
	abstract = {In cryptography, a preimage attack  on cryptographic hash functions tries to find a message that has a specific hash value. A cryptographic hash function should resist attacks on its preimage (set of possible inputs).
In the context of attack, there are two types of preimage resistance:

preimage resistance: for essentially all pre-specified outputs, it is computationally infeasible to find any input that hashes to that output, i.e., given y, it is difficult to find an x such that h(x) = y.
second-preimage resistance: it is computationally infeasible to find any second input which has the same output as that of a specified input, i.e., given x, it is difficult to find a second preimage x′ ≠ x such that h(x) = h(x′).These can be compared with a collision resistance, in which it is computationally infeasible to find any two distinct inputs x, x′ that hash to the same output, i.e., such that h(x) = h(x′).Collision resistance implies second-preimage resistance, but does not guarantee preimage resistance. Conversely, a second-preimage attack implies a collision attack (trivially, since, in addition to x′, x is already known right from the start).},
	language = {en},
	urldate = {2020-03-09},
	journal = {Wikipedia},
	month = jun,
	year = {2019},
	note = {Page Version ID: 902805697},
	file = {Snapshot:/home/jani/Zotero/storage/ZNJHDC4H/index.html:text/html}
}

@misc{noauthor_understanding-vdfs_nodate,
	title = {understanding-vdfs},
	url = {https://wborgeaud.github.io/posts/understanding-vdfs.html},
	urldate = {2020-03-09},
	file = {understanding-vdfs:/home/jani/Zotero/storage/5JPE35JG/understanding-vdfs.html:text/html}
}

@misc{noauthor_zero_nodate,
	title = {Zero {Knowledge} {Proofs} - {Computerphile}},
	url = {https://www.youtube.com/watch?v=HUs1bH85X9I&t=412s},
	abstract = {How do you prove something without giving away all your data? Zero Knowledge Proofs could hold the answer. Alberto Sonnino, Research Student at UCL explains. 

EXTRA BITS: https://youtu.be/RK\_pNQ3QCKA 
Computing Limits: https://youtu.be/jv2H9fp9dT8

UCL Link: http://bit.ly/C\_UCL-people 

https://www.facebook.com/computerphile
https://twitter.com/computer\_phile

This video was filmed and edited by Sean Riley.

Computer Science at the University of Nottingham: https://bit.ly/nottscomputer

Computerphile is a sister project to Brady Haran's Numberphile. More at http://www.bradyharan.com},
	urldate = {2020-03-09}
}

@article{thaler_pcps_nodate,
	title = {{PCPs} and {Succinct} {Arguments}},
	language = {en},
	author = {Thaler, Justin},
	pages = {5},
	file = {Thaler - PCPs and Succinct Arguments.pdf:/home/jani/Zotero/storage/ZGWVJB3B/Thaler - PCPs and Succinct Arguments.pdf:application/pdf}
}

@techreport{bitansky_succinct_2012,
	title = {Succinct {Arguments} from {Multi}-{Prover} {Interactive} {Proofs} and their {Efficiency} {Benefits}},
	url = {http://eprint.iacr.org/2012/461},
	abstract = {{\textbackslash}emph\{Succinct arguments of knowledge\} are computationally-sound proofs of knowledge for NP where the verifier's running time is independent of the time complexity \$t\$ of the nondeterministic NP machine \$M\$ that decides the given language.



Existing succinct argument constructions are, typically, based on techniques that combine cryptographic hashing and probabilistically-checkable proofs (PCPs). Yet, even when instantiating these constructions with state-of-the-art PCPs, the prover needs \${\textbackslash}Omega(t)\$ space in order to run in quasilinear time (i.e., time \$t {\textbackslash}poly(k)\$), regardless of the space complexity \$s\$ of the machine \$M\$.

We say that a succinct argument is {\textbackslash}emph\{complexity preserving\} if the prover runs in time \$t {\textbackslash}poly(k)\$ and space \$s {\textbackslash}poly(k)\$ and the verifier runs in time \${\textbar}x{\textbar} {\textbackslash}poly(k)\$ when proving and verifying that a \$t\$-time \$s\$-space random-access machine nondeterministically accepts an input \$x\$. Do complexity-preserving succinct arguments exist? To study this question, we investigate the alternative approach of constructing succinct arguments based on multi-prover interactive proofs (MIPs) and stronger cryptographic techniques:

(1) We construct a one-round succinct MIP of knowledge, where each prover runs in time \$t {\textbackslash}polylog(t)\$ and space \$s {\textbackslash}polylog(t)\$ and the verifier runs in time \${\textbar}x{\textbar} {\textbackslash}polylog(t)\$.

(2) We show how to transform any one-round MIP protocol to a succinct four-message argument (with a single prover), while preserving the time and space efficiency of the original MIP protocol; using our MIP protocol, this transformation yields a complexity-preserving four-message succinct argument.

As a main tool for our transformation, we define and construct a {\textbackslash}emph\{succinct multi-function commitment\} that (a) allows the sender to commit to a vector of functions in time and space complexity that are essentially the same as those needed for a single evaluation of the functions, and (b) ensures that the receiver's running time is essentially independent of the function. The scheme is based on fully-homomorphic encryption (and no additional assumptions are needed for our succinct argument).

(3) In addition, we revisit the problem of {\textbackslash}emph\{non-interactive\} succinct arguments of knowledge (SNARKs), where known impossibilities prevent solutions based on black-box reductions to standard assumptions. We formulate a natural (but non-standard) variant of homomorphic encryption having a {\textbackslash}emph\{homomorphism-extraction property\}. We show that this primitive essentially allows to squash our interactive protocol, while again preserving time and space efficiency, thereby obtaining a complexity-preserving SNARK. We further show that this variant is, in fact, implied by the existence of (complexity-preserving) SNARKs.},
	number = {461},
	urldate = {2020-03-09},
	author = {Bitansky, Nir and Chiesa, Alessandro},
	year = {2012},
	keywords = {foundations, succinct arguments; delegation of computation; multi-prover interactive proofs; succinct function commitment; SNARKs},
	annote = {Extracted Annotations (4/23/2020, 4:21:25 PM)
"Succinct arguments of knowledge are computationally-sound proofs of knowledge for NP where the verifier's running time is independent of the time complexity t of the nondeterministic NP machine M that decides the given language." (Bitansky and Chiesa 2012:1)},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/72BLDXER/Bitansky and Chiesa - 2012 - Succinct Arguments from Multi-Prover Interactive P.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/FG47H5ZM/461.html:text/html}
}

@article{cohen_chia_nodate,
	title = {The {Chia} {Network} {Blockchain}},
	abstract = {This document outlines the basic design principles of the consensus layer (the blockchain) of the Chia network. It is inspired by and similar to the Bitcoin blockchain, which achieves consensus when a majority of the computing power dedicated towards securing it is controlled by honest parties. In Chia the resource is not computing power, but disk space.},
	language = {en},
	author = {Cohen, Bram and Pietrzak, Krzysztof},
	pages = {44},
	file = {Cohen and Pietrzak - The Chia Network Blockchain.pdf:/home/jani/Zotero/storage/AX4KQPR9/Cohen and Pietrzak - The Chia Network Blockchain.pdf:application/pdf}
}

@misc{noauthor_chia-networkvdf-competition_nodate,
	title = {Chia-{Network}/vdf-competition},
	url = {https://github.com/Chia-Network/vdf-competition},
	abstract = {Contribute to Chia-Network/vdf-competition development by creating an account on GitHub.},
	language = {en},
	urldate = {2020-03-09},
	journal = {GitHub},
	note = {Library Catalog: github.com},
	file = {Snapshot:/home/jani/Zotero/storage/ZSTALUPY/classgroups.html:text/html}
}

@incollection{goos_two_1999,
	address = {Berlin, Heidelberg},
	title = {Two {Party} {RSA} {Key} {Generation}},
	volume = {1666},
	isbn = {978-3-540-66347-8 978-3-540-48405-9},
	url = {http://link.springer.com/10.1007/3-540-48405-1_8},
	abstract = {We present a protocol for two parties to generate an RSA key in a distributed manner. At the end of the protocol the public key: a modulus N = P Q, and an encryption exponent e are known to both parties. Individually, neither party obtains information about the decryption key d and the prime factors of N : P and Q. However, d is shared among the parties so that threshold decryption is possible.},
	language = {en},
	urldate = {2020-03-09},
	booktitle = {Advances in {Cryptology} — {CRYPTO}’ 99},
	publisher = {Springer Berlin Heidelberg},
	author = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Gilboa, Niv},
	editor = {Wiener, Michael},
	year = {1999},
	doi = {10.1007/3-540-48405-1_8},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {116--129},
	file = {Goos et al. - 1999 - Two Party RSA Key Generation.pdf:/home/jani/Zotero/storage/9VCJ2EH9/Goos et al. - 1999 - Two Party RSA Key Generation.pdf:application/pdf}
}

@misc{noauthor_paritytechfinality-grandpa_2020,
	title = {paritytech/finality-grandpa},
	copyright = {Apache-2.0},
	url = {https://github.com/paritytech/finality-grandpa},
	abstract = {finality gadget for blockchains using common prefix agreement},
	urldate = {2020-03-09},
	publisher = {Parity Technologies},
	month = feb,
	year = {2020},
	note = {original-date: 2018-06-26T12:48:53Z}
}

@article{buterin_casper_2019,
	title = {Casper the {Friendly} {Finality} {Gadget}},
	url = {http://arxiv.org/abs/1710.09437},
	abstract = {We introduce Casper, a proof of stake-based finality system which overlays an existing proof of work blockchain. Casper is a partial consensus mechanism combining proof of stake algorithm research and Byzantine fault tolerant consensus theory. We introduce our system, prove some desirable features, and show defenses against long range revisions and catastrophic crashes. The Casper overlay provides almost any proof of work chain with additional protections against block reversions.},
	urldate = {2020-03-10},
	journal = {arXiv:1710.09437 [cs]},
	author = {Buterin, Vitalik and Griffith, Virgil},
	month = jan,
	year = {2019},
	note = {arXiv: 1710.09437},
	keywords = {Computer Science - Cryptography and Security},
	annote = {Comment: 10 pages, 5 figures},
	file = {arXiv Fulltext PDF:/home/jani/Zotero/storage/9PPJ72X3/Buterin and Griffith - 2019 - Casper the Friendly Finality Gadget.pdf:application/pdf;arXiv.org Snapshot:/home/jani/Zotero/storage/4W65XJZY/1710.html:text/html}
}

@techreport{dobson_trustless_2020,
	title = {Trustless {Groups} of {Unknown} {Order} with {Hyperelliptic} {Curves}},
	url = {http://eprint.iacr.org/2020/196},
	abstract = {We suggest an alternative method of generating groups of unknown order for constructions such as cryptographic accumulators, by using the Jacobian groups of hyperelliptic curves (especially of genus 3). We propose that this construction is more efficient in practice than other proposals such as the use of ideal class groups of imaginary quadratic fields. We suggest that both the group operation and the size of element representation is an improvement over class groups. We also offer potential parameter choices for security with respect to best current algorithms for calculating the order of these groups.},
	number = {196},
	urldate = {2020-03-11},
	author = {Dobson, Samuel and Galbraith, Steven D.},
	year = {2020},
	keywords = {cryptographic protocols, accumulators, hyperelliptic curves, unknown order groups},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/FTW3C45C/Dobson and Galbraith - 2020 - Trustless Groups of Unknown Order with Hyperellipt.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/4CCKAFXH/196.html:text/html}
}

@techreport{malavolta_homomorphic_2019,
	title = {Homomorphic {Time}-{Lock} {Puzzles} and {Applications}},
	url = {http://eprint.iacr.org/2019/635},
	abstract = {Time-lock puzzles allow one to encrypt messages for the future, by efficiently generating a puzzle with a solution \$s\$ that remains hidden until time \$T\$ has elapsed. The solution is required to be concealed from the eyes of any algorithm running in (parallel) time less than \$T\$.



We put forth the concept of {\textbackslash}emph\{homomorphic time-lock puzzles\}, where one can evaluate functions over puzzles without solving them, i.e., one can manipulate a set of puzzles with solutions \$(s\_1, {\textbackslash}dots, s\_n)\$ to obtain a puzzle that solves to \$f(s\_1, {\textbackslash}ldots, s\_n)\$, for any function \$f\$. We propose candidate constructions under concrete cryptographic assumptions for different classes of functions. Then we show how homomorphic time-lock puzzles overcome the limitations of classical time-lock puzzles by proposing new protocols for applications of interest, such as e-voting, multi-party coin flipping, and fair contract signing.},
	number = {635},
	urldate = {2020-03-11},
	author = {Malavolta, Giulio and Thyagarajan, Sri Aravinda Krishnan},
	year = {2019},
	keywords = {Homomorphic Encryption, public-key cryptography, Time-Lock Puzzles},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/93R3GPKS/Malavolta and Thyagarajan - 2019 - Homomorphic Time-Lock Puzzles and Applications.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/63RE28W4/635.html:text/html}
}

@article{thaler_verifiable_nodate,
	title = {Verifiable {Computing}: {Between} {Theory} and {Practice}},
	language = {en},
	author = {Thaler, Justin},
	pages = {55},
	file = {Thaler - Verifiable Computing Between Theory and Practice.pdf:/home/jani/Zotero/storage/GZ3J6C8H/Thaler - Verifiable Computing Between Theory and Practice.pdf:application/pdf}
}

@techreport{cherniaeva_homomorphic_2019,
	title = {Homomorphic {Encryption} {Random} {Beacon}},
	url = {http://eprint.iacr.org/2019/1320},
	abstract = {A reliable source of randomness is a critical element in many cryptographic systems. A public randomness beacon is a randomness source generated in a distributed manner that satisfies the following requirements: Liveness, Unpredictability, Unbiasability and Public Verifiability. In this work we introduce HERB: a new randomness beacon protocol based on additively homomorphic encryption. We show that this protocol meets the requirements listed above and additionaly provides Guaranteed Output Delivery. HERB has a modular structure with two replaceable modules: an homomorphic cryptosystem and a consensus algorithm. In our analysis we instantiate HERB using ElGamal encryption and a public blockchain. We implemented a prototype using Cosmos SDK to demonstrate the simplicity and efficiency of our approach. HERB allows splitting all protocol participants into two groups that can relate in any way. This property can be used for building more complex participation and reward systems based on the HERB solution.},
	number = {1320},
	urldate = {2020-03-20},
	author = {Cherniaeva, Alisa and Shirobokov, Ilia and Shlomovits, Omer},
	year = {2019},
	keywords = {cryptographic protocols, randomness beacons, distributed cryptography, distributed randomness, homomorphic encryption},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/ZAECPT9X/Cherniaeva et al. - 2019 - Homomorphic Encryption Random Beacon.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/3XXLGHMH/1320.html:text/html}
}

@misc{noauthor_kzen-networkswhite-city_nodate,
	title = {{KZen}-networks/white-city},
	url = {https://github.com/KZen-networks/white-city},
	abstract = {Network layer for MPC (Secure Multi-Party Computation) based on Tendermint  - KZen-networks/white-city},
	language = {en},
	urldate = {2020-03-20},
	journal = {GitHub},
	note = {Library Catalog: github.com},
	file = {Snapshot:/home/jani/Zotero/storage/XSNB3F2B/white_city.html:text/html}
}

@misc{noauthor_preimage_2019-1,
	title = {Preimage attack},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Preimage_attack&oldid=902805697},
	abstract = {In cryptography, a preimage attack  on cryptographic hash functions tries to find a message that has a specific hash value. A cryptographic hash function should resist attacks on its preimage (set of possible inputs).
In the context of attack, there are two types of preimage resistance:

preimage resistance: for essentially all pre-specified outputs, it is computationally infeasible to find any input that hashes to that output, i.e., given y, it is difficult to find an x such that h(x) = y.
second-preimage resistance: it is computationally infeasible to find any second input which has the same output as that of a specified input, i.e., given x, it is difficult to find a second preimage x′ ≠ x such that h(x) = h(x′).These can be compared with a collision resistance, in which it is computationally infeasible to find any two distinct inputs x, x′ that hash to the same output, i.e., such that h(x) = h(x′).Collision resistance implies second-preimage resistance, but does not guarantee preimage resistance. Conversely, a second-preimage attack implies a collision attack (trivially, since, in addition to x′, x is already known right from the start).},
	language = {en},
	urldate = {2020-03-19},
	journal = {Wikipedia},
	month = jun,
	year = {2019},
	note = {Page Version ID: 902805697},
	file = {Snapshot:/home/jani/Zotero/storage/3X9MIKB7/index.html:text/html}
}

@techreport{bunz_proofs_2019,
	title = {Proofs for {Inner} {Pairing} {Products} and {Applications}},
	url = {https://eprint.iacr.org/2019/1177},
	abstract = {We present a generalized inner product argument and demonstrate its applications to pairing-based languages. As a first instantiation, we introduce a statistically sound proof for the product ofpairings given public source group elements. This protocol enables outsourcing many pairing equation checks to an untrusted prover. Proofs aretarget group elements, computed usingpairings andexponentiations in each source group. There is no setup. The verifier work is dominated by two multi-exponentiations of sizewhich require time. Asymptotically, verification is thus faster than computing theMiller loops that dominate the pairing product computation; indeed, our implementation demonstrates aspeedup for a million pairings.},
	number = {1177},
	urldate = {2020-03-19},
	author = {Bünz, Benedikt and Maller, Mary and Mishra, Pratyush and Vesely, Noah},
	year = {2019},
	keywords = {public-key cryptography, aggregate proofs, aggregate signatures, bilinear pairings, inner pairing product, structure-preserving cryptography},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/4X7AHQQJ/Bünz et al. - 2019 - Proofs for Inner Pairing Products and Applications.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/U7ZEIZCA/1177.html:text/html}
}

@misc{noauthor_interactive_2020,
	title = {Interactive proof system},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Interactive_proof_system&oldid=937341343},
	abstract = {In computational complexity theory, an interactive proof system is an abstract machine that models computation as the exchange of messages between two parties. The parties, the verifier and the prover, interact by exchanging messages in order to ascertain whether a given string belongs to a language or not. The prover is all-powerful and possesses unlimited computational resources, but cannot be trusted, while the verifier has bounded computation power. Messages are sent between the verifier and prover until the verifier has an answer to the problem and has "convinced" itself that it is correct.
All interactive proof systems have two requirements:

Completeness: if the statement is true, the honest verifier (that is, one following the protocol properly) can be convinced of this fact by an untrusted prover.
Soundness: if the statement is false, no prover, even if it doesn't follow the protocol, can convince the honest verifier that it is true, except with some small probability.It is assumed that the verifier is always honest.
The specific nature of the system, and so the complexity class of languages it can recognize, depends on what sort of bounds are put on the verifier, as well as what abilities it is given—for example, most interactive proof systems depend critically on the verifier's ability to make random choices. It also depends on the nature of the messages exchanged—how many and what they can contain. Interactive proof systems have been found to have some important implications for traditional complexity classes defined using only one machine. The main complexity classes describing interactive proof systems are AM and  IP.},
	language = {en},
	urldate = {2020-03-18},
	journal = {Wikipedia},
	month = jan,
	year = {2020},
	note = {Page Version ID: 937341343},
	file = {Snapshot:/home/jani/Zotero/storage/HVS7HHV9/index.html:text/html}
}

@inproceedings{cholez_evaluation_2009,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Evaluation of {Sybil} {Attacks} {Protection} {Schemes} in {KAD}},
	isbn = {978-3-642-02627-0},
	doi = {10.1007/978-3-642-02627-0_6},
	abstract = {In this paper, we assess the protection mechanisms entered into recent clients to fight against the Sybil attack in KAD, a widely deployed Distributed Hash Table. We study three main mechanisms: a protection against flooding through packet tracking, an IP address limitation and a verification of identities. We evaluate their efficiency by designing and adapting an attack for several KAD clients with different levels of protection. Our results show that the new security rules mitigate the Sybil attacks previously launched. However, we prove that it is still possible to control a small part of the network despite the new inserted defenses with a distributed eclipse attack and limited resources.},
	language = {en},
	booktitle = {Scalability of {Networks} and {Services}},
	publisher = {Springer},
	author = {Cholez, Thibault and Chrisment, Isabelle and Festor, Olivier},
	editor = {Sadre, Ramin and Pras, Aiko},
	year = {2009},
	keywords = {defense, DHT, KAD, P2P networks, security, Sybil attack},
	pages = {70--82},
	file = {Springer Full Text PDF:/home/jani/Zotero/storage/B6ABD6GQ/Cholez et al. - 2009 - Evaluation of Sybil Attacks Protection Schemes in .pdf:application/pdf}
}

@article{awerbuch_towards_2009,
	title = {Towards a {Scalable} and {Robust} {DHT}},
	volume = {45},
	issn = {1433-0490},
	url = {https://doi.org/10.1007/s00224-008-9099-9},
	doi = {10.1007/s00224-008-9099-9},
	abstract = {The problem of scalable and robust distributed data storage has recently attracted a lot of attention. A common approach in the area of peer-to-peer systems has been to use a distributed hash table (or DHT). DHTs are based on the concept of virtual space. Peers and data items are mapped to points in that space, and local-control rules are used to decide, based on these virtual locations, how to interconnect the peers and how to map the data to the peers.},
	language = {en},
	number = {2},
	urldate = {2020-03-16},
	journal = {Theory of Computing Systems},
	author = {Awerbuch, Baruch and Scheideler, Christian},
	month = aug,
	year = {2009},
	pages = {234--260},
	file = {Springer Full Text PDF:/home/jani/Zotero/storage/TUQGVFLG/Awerbuch and Scheideler - 2009 - Towards a Scalable and Robust DHT.pdf:application/pdf}
}

@inproceedings{villanueva_secure_2010,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Secure {Routing} {Strategies} in {DHT}-{Based} {Systems}},
	isbn = {978-3-642-15108-8},
	doi = {10.1007/978-3-642-15108-8_6},
	abstract = {Due to the inherent characteristics of peer-to-peer systems, one of the barriers to deploy applications over public networks is the different security levels that have to be provided. Peer-to-peer systems are vulnerable to several attacks. In particular, for routing attacks, an adversary attempts to mis-route or drop messages along the routing procedure or corrupt routing table entries, thus degrading the overall routing process. In this paper, we propose a taxonomy of solutions to the routing attack, identify new issues and shape future directions.},
	language = {en},
	booktitle = {Data {Management} in {Grid} and {Peer}-to-{Peer} {Systems}},
	publisher = {Springer},
	author = {Villanueva, Ricardo and del Pilar Villamil, Maria and Arnedo, Mile},
	editor = {Hameurlain, Abdelkader and Morvan, Franck and Tjoa, A. Min},
	year = {2010},
	keywords = {Distribute Hash Table, Faulty Node, Malicious Node, Overlay Network, Reputation System},
	pages = {62--74},
	file = {Springer Full Text PDF:/home/jani/Zotero/storage/4XU7ML4Z/Villanueva et al. - 2010 - Secure Routing Strategies in DHT-Based Systems.pdf:application/pdf}
}

@misc{noauthor_eclipse_nodate,
	title = {Eclipse {Attacks} on {Blockchains}’ {Peer}-to-{Peer} {Network}},
	url = {https://hackernoon.com/eclipse-attacks-on-blockchains-peer-to-peer-network-26a62f85f11},
	language = {en},
	urldate = {2020-03-16},
	note = {Library Catalog: hackernoon.com},
	file = {Snapshot:/home/jani/Zotero/storage/76DCLLRH/eclipse-attacks-on-blockchains-peer-to-peer-network-26a62f85f11.html:text/html}
}

@misc{simonsson_orchid_2018,
	title = {Orchid {Tech}: {DHTs} and {Eclipse} {Attacks}},
	shorttitle = {Orchid {Tech}},
	url = {https://medium.com/@gustav.simonsson/orchid-tech-dhts-and-eclipse-attacks-5abd62773df5},
	abstract = {The Orchid project is committed to open source and open R\&D collaboration around technology to build a new, decentralized Internet. The…},
	language = {en},
	urldate = {2020-03-16},
	journal = {Medium},
	author = {Simonsson, Gustav},
	month = dec,
	year = {2018},
	note = {Library Catalog: medium.com},
	file = {Snapshot:/home/jani/Zotero/storage/XXPPTYJ7/orchid-tech-dhts-and-eclipse-attacks-5abd62773df5.html:text/html}
}

@inproceedings{al-ameen_design_2014,
	address = {Kyoto, Japan},
	series = {{ASIA} {CCS} '14},
	title = {Design and evaluation of persea, a sybil-resistant {DHT}},
	isbn = {978-1-4503-2800-5},
	url = {http://doi.org/10.1145/2590296.2590326},
	doi = {10.1145/2590296.2590326},
	abstract = {P2P systems are inherently vulnerable to Sybil attacks, in which an attacker creates a large number of identities and uses them to control a substantial fraction of the system. We propose Persea, a novel P2P system that derives its Sybil resistance by assigning IDs through a bootstrap tree, the graph of how nodes have joined the system through invitations. Unlike prior Sybil-resistant P2P systems based on social networks, Persea does not rely on two key assumptions: (1) that the social network is fast mixing and (2) that there is a small ratio of attack edges to honest nodes. Both assumptions have been shown to be unreliable in real social networks. A node joins Persea when it gets an invitation from an existing node in the system. The inviting node assigns a node ID to the joining node and gives it a chunk of node IDs for further distribution. For each chunk of ID space, the attacker needs to socially engineer a connection to another node already in the system. The hierarchical distribution of node IDs confines a large attacker botnet to a considerably smaller region of the ID space than in a normal P2P system. We then build upon this hierarchical ID space to make a distributed hash table (DHT) based on the Kad network. The Persea DHT uses a replication mechanism in which each (key, value) pair is stored in nodes that are evenly spaced over the network. Thus, even if a given region is occupied by attackers, the desired (key, value pair can be retrieved from other regions. We evaluate Persea in analysis and in simulations with social network datasets and show that it provides better lookup success rates than prior work with modest overheads.},
	urldate = {2020-03-16},
	booktitle = {Proceedings of the 9th {ACM} symposium on {Information}, computer and communications security},
	publisher = {Association for Computing Machinery},
	author = {Al-Ameen, Mahdi Nasrullah and Wright, Matthew},
	month = jun,
	year = {2014},
	keywords = {security, Sybil attack, social DHT},
	pages = {75--86},
	file = {Full Text PDF:/home/jani/Zotero/storage/9KH7NBFG/Al-Ameen and Wright - 2014 - Design and evaluation of persea, a sybil-resistant.pdf:application/pdf}
}

@article{urdaneta_survey_2011,
	title = {A survey of {DHT} security techniques},
	volume = {43},
	issn = {0360-0300},
	url = {http://doi.org/10.1145/1883612.1883615},
	doi = {10.1145/1883612.1883615},
	abstract = {Peer-to-peer networks based on distributed hash tables (DHTs) have received considerable attention ever since their introduction in 2001. Unfortunately, DHT-based systems have been shown to be notoriously difficult to protect against security attacks. Various reports have been published that discuss or classify general security issues, but so far a comprehensive survey describing the various proposed defenses has been lacking. In this article, we present an overview of techniques reported in the literature for making DHT-based systems resistant to the three most important attacks that can be launched by malicious nodes participating in the DHT: (1) the Sybil attack, (2) the Eclipse attack, and (3) routing and storage attacks. We review the advantages and disadvantages of the proposed solutions and, in doing so, confirm how difficult it is to secure DHT-based systems in an adversarial environment.},
	number = {2},
	urldate = {2020-03-16},
	journal = {ACM Computing Surveys},
	author = {Urdaneta, Guido and Pierre, Guillaume and Steen, Maarten Van},
	month = feb,
	year = {2011},
	keywords = {Sybil attack, Eclipse attack, distributed hash tables, Peer-to-peer systems, secure P2P routing and storage},
	pages = {8:1--8:49},
	file = {Full Text PDF:/home/jani/Zotero/storage/6GFPHNPL/Urdaneta et al. - 2011 - A survey of DHT security techniques.pdf:application/pdf}
}

@article{ismail_p2p_2017,
	title = {{P2P} routing table poisoning: {A} quorum-based sanitizing approach},
	volume = {65},
	issn = {0167-4048},
	shorttitle = {{P2P} routing table poisoning},
	url = {http://www.sciencedirect.com/science/article/pii/S016740481630178X},
	doi = {10.1016/j.cose.2016.12.007},
	abstract = {Peer-to-Peer (P2P) protocols underlie multiple networked applications given that the P2P decentralized design inherently fosters scalability and robustness. While distributiveness and scalability are attractive features, these facets also increase exposure to malicious peers which can propagate malicious routing information. Accordingly, a diverse set of continuously evolving attacks can be mounted that can cause severe service impairments over the entire overlay network. Most proposed countermeasures focus on providing diversity or redundancy to overcome malicious routing information with their emphasis on periodic detection/removal mechanisms done locally within a peer as continuous monitoring or global sharing of peer status entails high costs. However, a local approach naturally also limits the global effectiveness prompting the need for distributed solutions. In this work, we build upon contemporary distributed solutions (that developed specific attack detection and mitigation techniques for specific overlay types and specific attacks), to propose a generalized attack detection and mitigation approach applicable to varied overlay and attack models. Consequently, we propose a novel and efficient routing table sanitizing approach that (a) is independent of a specific attack variant, lookup approach or a specific victim set, (b) continuously detects and subsequently removes malicious routing information based on distributed quorum decisions, and (c) efficiently forwards malicious information findings to other peers which allows for progressive global sanitizing. The generalized mechanism shows a high sanitizing accuracy of up to 90\% when evaluated against a generalized attack scenario with various adversarial behaviors.},
	language = {en},
	urldate = {2020-03-16},
	journal = {Computers \& Security},
	author = {Ismail, Hatem and Germanus, Daniel and Suri, Neeraj},
	month = mar,
	year = {2017},
	keywords = {Attacks, Detection, P2P, Sanitizing, Security},
	pages = {283--299},
	file = {ScienceDirect Full Text PDF:/home/jani/Zotero/storage/DVL65Y8R/Ismail et al. - 2017 - P2P routing table poisoning A quorum-based saniti.pdf:application/pdf;ScienceDirect Snapshot:/home/jani/Zotero/storage/BSD75TYQ/S016740481630178X.html:text/html}
}

@article{lopez-fuentes_evaluating_2012,
	series = {The 2012 {Iberoamerican} {Conference} on {Electronics} {Engineering} and {Computer} {Science}},
	title = {Evaluating {P2P} {Networks} against {Eclipse} {Attacks}},
	volume = {3},
	issn = {2212-0173},
	url = {http://www.sciencedirect.com/science/article/pii/S2212017312002368},
	doi = {10.1016/j.protcy.2012.03.007},
	abstract = {Due to its distributed nature, the P2P networks are subject to more intricate attacks than client-server networks. Therefore, the security issues on a P2P network represent a great research challenge. Most P2P networks do not have a central management, and causes them can be endangered by its own nodes if enough of them decide to behave maliciously. In this paper, we evaluate the performance of P2P networks against an Eclipse attacks. Specifically, we evaluate the performance of the unstructured P2P networks and super-peer P2P systems against the Eclipse attack. To this end, our simulations are realized using schemes based on Gnutella and KazaA. Both networks are evaluated in terms of number of affected peers and their performance. Our results show that an Eclipse attack may have different effects on different kinds of P2P networks.},
	language = {en},
	urldate = {2020-03-16},
	journal = {Procedia Technology},
	author = {López-Fuentes, Francisco de Asís and Eugui-De-Alba, Iñaki and Ortíz-Ruiz, Otoniel M.},
	month = jan,
	year = {2012},
	keywords = {security, Eclipse attack, overlay network, Peer-to-Peer networks},
	pages = {61--68},
	file = {ScienceDirect Full Text PDF:/home/jani/Zotero/storage/D9LYUB49/López-Fuentes et al. - 2012 - Evaluating P2P Networks against Eclipse Attacks.pdf:application/pdf;ScienceDirect Snapshot:/home/jani/Zotero/storage/EJYQHMDS/S2212017312002368.html:text/html}
}

@misc{noauthor_ieee_nodate,
	title = {{IEEE} {Xplore} {Digital} {Library}},
	url = {https://ieeexplore-ieee-org.ezproxy.utu.fi/Xplore/home.jsp},
	urldate = {2020-03-16},
	file = {IEEE Xplore Digital Library:/home/jani/Zotero/storage/AIHPJB6S/home.html:text/html}
}

@article{zou_survey_2011,
	title = {Survey of eclipse attacks on {DHT} networks},
	volume = {51},
	abstract = {The Distributed Hash table (DHT) is the core of structural peer-to-peer networks. There are millions of nodes in DHT networks in practical P2P applications. However, DHT networks still have many security problems which have not been resolved. The eclipse attack is a typical DHT network security threat. This paper describes the common eclipse attack methods and summarizes recent research on detection methods and eclipse attack defenses. The methods are compared in terms of applicable conductions, dependencies and performance. New issues and future directions for eclipse attacks are also given.},
	journal = {Qinghua Daxue Xuebao/Journal of Tsinghua University},
	author = {Zou, W. and Zhang, Y. and Zhang, J. and Zhou, M. and Liu, B.},
	month = oct,
	year = {2011},
	pages = {1306--1311}
}

@misc{noauthor_random_2020,
	title = {Random oracle},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Random_oracle&oldid=944246666},
	abstract = {In cryptography, a random oracle is an oracle (a theoretical black box) that responds to every unique query with a (truly) random response chosen uniformly from its output domain. If a query is repeated, it responds the same way every time that query is submitted.
Stated differently, a random oracle is a mathematical function chosen uniformly at random, that is, a function mapping each possible query to a (fixed) random response from its output domain.
Random oracles as a mathematical abstraction were firstly used in rigorous cryptographic proofs in the 1993 publication by Mihir Bellare and Phillip Rogaway (1993). They are typically used when the proof cannot be carried out using weaker assumptions on the cryptographic hash function. A system that is proven secure when every hash function is replaced by a random oracle is described as being secure in the random oracle model, as opposed to secure in the standard model of cryptography.},
	language = {en},
	urldate = {2020-03-15},
	journal = {Wikipedia},
	month = mar,
	year = {2020},
	note = {Page Version ID: 944246666},
	file = {Snapshot:/home/jani/Zotero/storage/P6BGT74R/index.html:text/html}
}

@article{wahby_airdrop_nodate,
	title = {An airdrop that preserves recipient privacy},
	abstract = {A common approach to bootstrapping a new cryptocurrency is an airdrop, an arrangement in which existing users give away currency to entice new users to join. But current airdrops oﬀer no recipient privacy: they leak which recipients have claimed the funds, and this information is easily linked to oﬀ-chain identities.},
	language = {en},
	author = {Wahby, Riad S and Boneh, Dan and Jeﬀrey, Christopher and Poon, Joseph},
	pages = {17},
	file = {Wahby et al. - An airdrop that preserves recipient privacy.pdf:/home/jani/Zotero/storage/VV8UATD4/Wahby et al. - An airdrop that preserves recipient privacy.pdf:application/pdf}
}

@book{iptps_2002_2002__cambridge_peer--peer_2002,
	title = {Peer-to-peer systems : {First} {International} {Workshop}, {IPTPS} 2002, {Cambridge}, {MA}, {USA}, {March} 7-8, 2002 : revised papers},
	shorttitle = {Peer-to-peer systems},
	url = {http://archive.org/details/peertopeersystem0000iptp},
	abstract = {ix, 337 p. : 24 cm; Includes bibliographical references and index},
	language = {eng},
	urldate = {2020-03-22},
	publisher = {Berlin ; New York : Springer},
	author = {IPTPS 2002 (2002 : Cambridge, Mass )},
	collaborator = {{Internet Archive}},
	year = {2002},
	keywords = {Peer-to-peer architecture (Computer networks) -- Congresses}
}

@misc{noauthor_kademlia_2020,
	title = {Kademlia},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Kademlia&oldid=936998972},
	abstract = {Kademlia is a distributed hash table for decentralized peer-to-peer computer networks designed by Petar Maymounkov and David Mazières in 2002. It specifies the structure of the network and the exchange of information through node lookups. Kademlia nodes communicate among themselves using UDP. A virtual or overlay network is formed by the participant nodes. Each node is identified by a number or node ID. The node ID serves not only as identification, but the Kademlia algorithm uses the node ID to locate values (usually file hashes or keywords). In fact, the node ID provides a direct map to file hashes and that node stores information on where to obtain the file or resource.
When searching for some value, the algorithm needs to know the associated key and explores the network in several steps. Each step will find nodes that are closer to the key until the contacted node returns the value or no more closer nodes are found. This is very efficient: like many other DHTs, Kademlia contacts only 
  
    
      
        O
        (
        log
        ⁡
        (
        n
        )
        )
      
    
    \{{\textbackslash}displaystyle O({\textbackslash}log(n))\}
   nodes during the search out of a total of 
  
    
      
        n
      
    
    \{{\textbackslash}displaystyle n\}
   nodes in the system.
Further advantages are found particularly in the decentralized structure, which increases the resistance against a denial-of-service attack. Even if a whole set of nodes is flooded, this will have limited effect on network availability, since the network will recover itself by knitting the network around these "holes".
I2P's implementation of Kademlia is modified to mitigate Kademlia's vulnerabilities, such as Sybil attacks.},
	language = {en},
	urldate = {2020-03-23},
	journal = {Wikipedia},
	month = jan,
	year = {2020},
	note = {Page Version ID: 936998972},
	annote = {Extracted Annotations (4/23/2020, 12:03:05 AM)
"Ö ,RYá] Ò [{\textasciicircum}*R e {\textasciitilde}[7,RY" ( 2020:1)
"Ó i\&w e {\textasciitilde}[L F Ií F \&w½\vphantom{\{}\}R1" ( 2020:2)
"Ö ,1 e Ò ½L" ( 2020:2)
"Ð A7RY] \_ Õ Ä T Y × ÕmRL" ( 2020:2)
" pY" ( 2020:4)
"Ö ,Y1 e d\&\#* j F \&[ ! El {\textasciicircum} Ò ! è d d3A 8 ã (¹ D \# 8@ ß Ô [ p \# w[+('R F Ä F X'R\%L" ( 2020:4)
" Ä F I T \vphantom{\{}\} \# w[A e 2\vphantom{\{}\}' T R1 e w[*R Q I{\textasciicircum}'" ( 2020:5)
"\# w[ Ò [A \# w[ e Aá] H dfw1á E d[ \# w[Ká e {\textasciitilde}[*L" ( 2020:5)
"\# w[{\textasciicircum}\% D iP Ò ½ d[{\textasciicircum}R E d*1" ( 2020:5)
"÷ e {\textasciitilde}f\&½1 \# w[AKá\% F X\&m{\textasciicircum}*á5 T RÄ \# P½+K T A{\textasciicircum}\%" ( 2020:5)
"Ð Aá " Ø Ø 3 (* " \% (5 A 2 6( 7 35" ( 2020:5)
"AY \_ ' Õm{\textasciicircum} \# 1 9 ã2R]! Y i L Õ'í T [ \_ G'R \# w[1 d[ Ú ½ï IA'í \% 6( (5 A" ( 2020:6)
"Ó iI 1" ( 2020:6)
"e K H dfV[A W N\&[3+R þ {\textasciicircum} W X\&R Ú e GI]Ú²" ( 2020:6)
" \vphantom{\{}\}K{\textasciicircum},R U \&R Q IYÀ T 3" ( 2020:7)
" \vphantom{\{}\}áL T " ( 2020:7)
"Ð 2 \&' O '7 T\_Õ½Ú \#w[ Ed['Y à\&2K7  w[ã3AK T{\textasciicircum}1 ÔL \#w[ \_G, "w[A" ( 2020:7)
"þ {\textasciicircum}]ï V[ d F \&[1 Ô K*" ( 2020:7)
"¤ - \vphantom{\{}\}á   GV 4 I I C ¢ ¢ ] , 4 {\textgreater} m 8 \% {\textgreater} ¢  0 I5 wP ( á4 Gw C m7  0 I Q m( ã ) ) m( Y I*  9 ¡ Iw 2 \%ã I á04 ) / (!C  ( " ( 2020:8)
"U \&]\% \# á] e {\textasciitilde}Y e (K, Z m+p" ( 2020:8)
" Ä T \_\&[á U \&w Ò ½1 é Ká \# (' U w[Ká e {\textasciitilde}K é KÚ T T [{\textasciicircum} T {\textasciicircum} ) + .5 ÿ R í e {\textasciicircum} ä  \_ ) + .5 Ó VRY]" ( 2020:9)
"Q \&3 \& pRY I\&[7R W XI 4 E × ÕP]5" ( 2020:10)
"Ô ½R \& ³ é K  ³ Ñ '1\%¹ \# w1 F , " ( 2020:10)
"ä  1 1L T [A" ( 2020:10)
"J dLí H df[RL \# F áí D \&í \# í" ( 2020:11)
"ä z]íï" ( 2020:11)
"Ð A P½ E 5 d\&²" ( 2020:11)
"\$( Ó G*L \# w[' \_   E f\#Y Ó VY F Z má] 2 ! \$(" ( 2020:11)
"Ä? Ó \&w, \# w[(\vphantom{\{}\}' \# , Ò A7 Ó i\&wí Q ) O , f 1 T ;W V ? T  w[7R" ( 2020:11)
"÷ ,Y Ô w" ( 2020:12)
"D m½] +\$ \vphantom{\{}\}1 e {\textasciitilde}i1\% P \# w[ Ñ [Y " ( 2020:12)
" Ä e {\textasciitilde}m î" ( 2020:12)
"H dVm[1" ( 2020:13)
"Z m['í p'Y1 Ô [KRY Ó X\&V3RÀ" ( 2020:13)},
	file = {maymounkov-kademlia-lncs.pdf:/home/jani/Zotero/storage/NBFFRUNV/maymounkov-kademlia-lncs.pdf:application/pdf;Snapshot:/home/jani/Zotero/storage/7T74ZR7W/index.html:text/html}
}

@misc{noauthor_vdf_nodate-1,
	title = {{VDF} open problems - {HackMD}},
	url = {https://notes.ethereum.org/bPQjvr0hQ8OIlwkZbO6o5A},
	language = {en},
	urldate = {2020-03-23},
	note = {Library Catalog: notes.ethereum.org},
	file = {Snapshot:/home/jani/Zotero/storage/Z6JWVRSZ/bPQjvr0hQ8OIlwkZbO6o5A.html:text/html}
}

@techreport{mahmoody_publicly_2011,
	title = {Publicly {Verifiable} {Proofs} of {Sequential} {Work}},
	url = {http://eprint.iacr.org/2011/553},
	abstract = {We construct a publicly verifiable protocol for proving computational work based on collision-resistant hash functions and a new plausible complexity assumption regarding the existence of "inherently sequential" hash functions. Our protocol is based on a novel construction of time-lock puzzles. Given a sampled "puzzle" \$P {\textbackslash}gets D\_n\$, where \$n\$ is the security parameter and \$D\_n\$ is the distribution of the puzzles, a corresponding "solution" can be generated using \$N\$ evaluations of the sequential hash function, where \$N{\textgreater}n\$ is another parameter, while any feasible adversarial strategy for generating valid solutions must take at least as much time as \${\textbackslash}Omega(N)\$ *sequential* evaluations of the hash function after receiving \$P\$. Thus, valid solutions constitute a "proof" that \${\textbackslash}Omega(N)\$ parallel time elapsed since \$P\$ was received. Solutions can be publicly and efficiently verified in time \${\textbackslash}poly(n) {\textbackslash}cdot {\textbackslash}polylog(N)\$. Applications of these "time-lock puzzles" include noninteractive timestamping of documents (when the distribution over the possible documents corresponds to the puzzle distribution \$D\_n\$) and universally verifiable CPU benchmarks.



Our construction is secure in the standard model under complexity assumptions (collision-resistant hash functions and inherently sequential hash functions), and makes black-box use of the underlying primitives. Consequently, the corresponding construction in the random oracle model is secure unconditionally. Moreover, as it is a public-coin protocol, it can be made non-interactive in the random oracle model using the Fiat-Shamir Heuristic.

Our construction makes a novel use of ``depth-robust'' directed acyclic graphs---ones whose depth remains large even after removing a constant fraction of vertices---which were previously studied for the purpose of complexity lower bounds. The construction bypasses a recent negative result of Mahmoody, Moran, and Vadhan (CRYPTO `11) for time-lock puzzles in the random oracle model, which showed that it is impossible to have time-lock puzzles like ours in the random oracle model if the puzzle generator also computes a solution together with the puzzle.},
	number = {553},
	urldate = {2020-03-23},
	author = {Mahmoody, Mohammad and Moran, Tal and Vadhan, Salil},
	year = {2011},
	keywords = {cryptographic protocols},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/FZAD5NXB/Mahmoody et al. - 2011 - Publicly Verifiable Proofs of Sequential Work.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/TZJL3SKC/553.html:text/html}
}

@techreport{goodell_compact_2019,
	title = {Compact linkable ring signatures and applications},
	url = {http://eprint.iacr.org/2019/654},
	abstract = {We introduce an efficient linkable ring multisignature construction, compact linkable spontaneous anonymous group (CLSAG) signatures. These admit d-dimensional keys with a specified linking coordinate but do not have signature sizes directly proportional to d. Compared to existing constructions used for signer-ambiguous confidential transactions without trusted setup, CLSAG signatures are smaller and more efficient in terms of both proving and verification time. CLSAG signatures also satisfy some rigorous security definitions: unforgeability depends upon the k-OMDL hardness assumption, linkability depends on unforgeability as well as the collision resistance of key aggregation, and signer-ambiguity depends on the DDH assumption. We demonstrate an application for CLSAG signatures for use in transacting multiple assets over ring signature-based transaction protocols.},
	number = {654},
	urldate = {2020-03-23},
	author = {Goodell, Brandon and Noether, Sarang and RandomRun},
	year = {2019},
	keywords = {applications, digital signatures, ring signatures},
	file = {ePrint IACR Full Text PDF:/home/jani/Zotero/storage/XL9RRVQY/Goodell et al. - 2019 - Compact linkable ring signatures and applications.pdf:application/pdf;ePrint IACR Snapshot:/home/jani/Zotero/storage/HD2MV5IE/654.html:text/html}
}

@misc{noauthor_diffiehellman_2020,
	title = {Diffie–{Hellman} key exchange},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Diffie%E2%80%93Hellman_key_exchange&oldid=946462919},
	abstract = {Diffie–Hellman key exchange is a method of securely exchanging cryptographic keys over a public channel and was one of the first public-key protocols as conceived by Ralph Merkle and named after Whitfield Diffie and Martin Hellman. DH is one of the earliest practical examples of public key exchange implemented within the field of cryptography.
Traditionally, secure encrypted communication between two parties required that they first exchange keys by some secure physical means, such as paper key lists transported by a trusted courier. The Diffie–Hellman key exchange method allows two parties that have no prior knowledge of each other to jointly establish a shared secret key over an insecure channel. This key can then be used to encrypt subsequent communications using a symmetric key cipher.
Diffie–Hellman is used to secure a variety of Internet services. However, research published in October 2015 suggests that the parameters in use for many DH Internet applications at that time are not strong enough to prevent compromise by very well-funded attackers, such as the security services of large governments.The scheme was published by Whitfield Diffie and Martin Hellman in 1976, but in 1997 it was revealed that James H. Ellis, Clifford Cocks, and Malcolm J. Williamson of GCHQ, the British signals intelligence agency, had previously shown in 1969 how public-key cryptography could be achieved.Although Diffie–Hellman key agreement itself is a non-authenticated key-agreement protocol, it provides the basis for a variety of authenticated protocols, and is used to provide forward secrecy in Transport Layer Security's ephemeral modes (referred to as EDH or DHE depending on the cipher suite).
The method was followed shortly afterwards by RSA, an implementation of public-key cryptography using asymmetric algorithms.
Expired U.S. Patent 4,200,770 from 1977 describes the now public-domain algorithm. It credits Hellman, Diffie, and Merkle as inventors.},
	language = {en},
	urldate = {2020-03-25},
	journal = {Wikipedia},
	month = mar,
	year = {2020},
	note = {Page Version ID: 946462919},
	file = {Snapshot:/home/jani/Zotero/storage/Z9UZKAIF/index.html:text/html}
}

@article{nakamoto_bitcoin_nodate,
	title = {Bitcoin: {A} {Peer}-to-{Peer} {Electronic} {Cash} {System}},
	abstract = {A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.},
	language = {en},
	author = {Nakamoto, Satoshi},
	pages = {9},
	file = {Nakamoto - Bitcoin A Peer-to-Peer Electronic Cash System.pdf:/home/jani/Zotero/storage/TUHB4YC2/Nakamoto - Bitcoin A Peer-to-Peer Electronic Cash System.pdf:application/pdf}
}

@misc{noauthor_consensus_2020,
	title = {Consensus (computer science)},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Consensus_(computer_science)&oldid=938841675},
	abstract = {A fundamental problem in distributed computing and multi-agent systems is to achieve overall system reliability in the presence of a number of faulty processes. This often requires processes to agree on some data value that is needed during computation. Examples of applications of consensus include whether to commit a transaction to a database, agreeing on the identity of a leader, state machine replication, and atomic broadcasts. The real world applications include clock synchronization, PageRank, opinion formation, smart power grids, state estimation, control of UAVs (and multiple robots/agents in general), load balancing, blockchain and others.},
	language = {en},
	urldate = {2020-03-26},
	journal = {Wikipedia},
	month = feb,
	year = {2020},
	note = {Page Version ID: 938841675},
	file = {Snapshot:/home/jani/Zotero/storage/S39KZRB7/index.html:text/html}
}

@misc{noauthor_commitment_2020,
	title = {Commitment scheme},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Commitment_scheme&oldid=947220858},
	abstract = {A commitment scheme is a cryptographic primitive that allows one to commit to a chosen value (or chosen statement) while keeping it hidden to others, with the ability to reveal the committed value later. Commitment schemes are designed so that a party cannot change the value or statement after they have committed to it: that is, commitment schemes are binding. Commitment schemes have important applications in a number of cryptographic protocols including secure coin flipping, zero-knowledge proofs, and secure computation.
A way to visualize a commitment scheme is to think of a sender as putting a message in a locked box, and giving the box to a receiver. The message in the box is hidden from the receiver, who cannot open the lock themselves. Since the receiver has the box, the message inside cannot be changed—merely revealed if the sender chooses to give them the key at some later time.
Interactions in a commitment scheme take place in two phases:

the commit phase during which a value is chosen and specified
the reveal phase during which the value is revealed and checkedIn simple protocols, the commit phase consists of a single message from the sender to the receiver. This message is called the commitment. It is essential that the specific value chosen cannot be known by the receiver at that time (this is called the hiding property). A simple reveal phase would consist of a single message, the opening, from the sender to the receiver, followed by a check performed by the receiver. The value chosen during the commit phase must be the only one that the sender can compute and that validates during the reveal phase (this is called the binding property).
The concept of commitment schemes was perhaps first formalized by Gilles Brassard, David Chaum, and Claude Crepeau in 1988, as part of various Zero-Knowledge protocols for NP, based on various types of commitment schemes (see also: ). But the concept was used without being treated formally prior to that. The notion of commitments appeared earliest in works by Manuel Blum, Shimon Even, and Shamir et al. The terminology seems to have been originated by Blum, although commitment schemes can be interchangeably called bit commitment schemes—sometimes reserved for the special case where the committed value is a bit. Earlier to that, commitment via one-way hash functions was considered, e.g., as part of, say, Lamport signature, the original  one-time one-bit signature scheme.},
	language = {en},
	urldate = {2020-04-01},
	journal = {Wikipedia},
	month = mar,
	year = {2020},
	note = {Page Version ID: 947220858},
	file = {Snapshot:/home/jani/Zotero/storage/VU6R8K3W/index.html:text/html}
}

@book{malkhi_concurrency_2019,
	address = {New York, NY, USA},
	title = {Concurrency: the {Works} of {Leslie} {Lamport}},
	isbn = {978-1-4503-7270-1},
	shorttitle = {Concurrency},
	abstract = {This book is a celebration of Leslie Lamport's work on concurrency, interwoven in four-and-a-half decades of an evolving industry: from the introduction of the first personal computer to an era when parallel and distributed multiprocessors are abundant. His works lay formal foundations for concurrent computations executed by interconnected computers. Some of the algorithms have become standard engineering practice for fault tolerant distributed computing - distributed systems that continue to function correctly despite failures of individual components. He also developed a substantial body of work on the formal specification and verification of concurrent systems, and has contributed to the development of automated tools applying these methods. Part I consists of technical chapters of the book and a biography. The technical chapters of this book present a retrospective on Lamport's original ideas from experts in the field. Through this lens, it portrays their long-lasting impact. The chapters cover timeless notions Lamport introduced: the Bakery algorithm, atomic shared registers and sequential consistency; causality and logical time; Byzantine Agreement; state machine replication and Paxos; temporal logic of actions (TLA). The professional biography tells of Lamport's career, providing the context in which his work arose and broke new grounds, and discusses LaTeX - perhaps Lamport's most influential contribution outside the field of concurrency. This chapter gives a voice to the people behind the achievements, notably Lamport himself, and additionally the colleagues around him, who inspired, collaborated, and helped him drive worldwide impact. Part II consists of a selection of Leslie Lamport's most influential papers. This book touches on a lifetime of contributions by Leslie Lamport to the field of concurrency and on the extensive influence he had on people working in the field. It will be of value to historians of science, and to researchers and students who work in the area of concurrency and who are interested to read about the work of one of the most influential researchers in this field.},
	publisher = {Association for Computing Machinery},
	editor = {Malkhi, Dahlia},
	year = {2019},
	file = {Full Text PDF:/home/jani/Zotero/storage/4735PCWX/Malkhi - 2019 - Concurrency the Works of Leslie Lamport.pdf:application/pdf}
}

@misc{noauthor_googletrillian_nodate,
	title = {google/trillian},
	url = {https://github.com/google/trillian},
	abstract = {A transparent, highly scalable and cryptographically verifiable data store. - google/trillian},
	language = {en},
	urldate = {2020-04-14},
	journal = {GitHub},
	note = {Library Catalog: github.com},
	file = {Snapshot:/home/jani/Zotero/storage/6RD4PJ62/VerifiableDataStructures.html:text/html}
}

@misc{noauthor_notion_nodate,
	title = {Notion – {The} all-in-one workspace for your notes, tasks, wikis, and databases.},
	url = {https://www.notion.so},
	abstract = {A new tool that blends your everyday work apps into one. It's the all-in-one workspace for you and your team},
	language = {en},
	urldate = {2020-04-21},
	journal = {Notion},
	note = {Library Catalog: www.notion.so},
	file = {Snapshot:/home/jani/Zotero/storage/UVQ76Z4B/login.html:text/html}
}

@misc{noauthor_fiatshamir_2020,
	title = {Fiat–{Shamir} heuristic},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Fiat%E2%80%93Shamir_heuristic&oldid=950323245},
	abstract = {In cryptography, the Fiat–Shamir heuristic is a technique for taking an interactive proof of knowledge and creating a digital signature based on it. This way, some fact (for example, knowledge of a certain secret number) can be publicly proven without revealing underlying information. The technique is due to Amos Fiat and Adi Shamir (1986).
For the method to work, the original interactive proof must have the property of being public-coin, i.e. verifier's random coins are made public throughout the proof protocol.
The heuristic was originally presented without a proof of security; later, Pointcheval and Stern proved its security against chosen message attacks in the random oracle model, that is, assuming random oracles exist. This result was generalized to the quantum-accessible random oracle (QROM) by Don, Fehr, Majenz and Schaffner, and concurrently by Liu and Zhandry. In the case that random oracles do not exist, the Fiat–Shamir heuristic has been proven insecure by Shafi Goldwasser and Yael Tauman Kalai. The Fiat–Shamir heuristic thus demonstrates a major application of random oracles. 
More generally, the Fiat–Shamir heuristic may also be viewed as converting a public-coin interactive proof of knowledge into a non-interactive proof of knowledge. If the interactive proof is used as an identification tool, then the non-interactive version can be used directly as a digital signature by using the message as part of the input to the random oracle.},
	language = {en},
	urldate = {2020-04-22},
	journal = {Wikipedia},
	month = apr,
	year = {2020},
	note = {Page Version ID: 950323245},
	file = {Snapshot:/home/jani/Zotero/storage/AGY5SBPF/index.html:text/html}
}

@misc{noauthor_discrete_2020,
	title = {Discrete logarithm},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Discrete_logarithm&oldid=950070994},
	abstract = {In the mathematics of the real numbers, the logarithm logb a is a number x such that bx = a, for given numbers a and b. Analogously, in any group G, powers bk can be defined for all integers k, and the discrete logarithm logb a is an integer k such that bk = a. In number theory, the more commonly used term is index: we can write x = indr a (mod m) (read the index of a to the base r modulo m) for rx ≡ a (mod m) if r is a primitive root of m and gcd(a,m) = 1.
Discrete logarithms are quickly computable in a few special cases. However, no efficient method is known for computing them in general. Several important algorithms in public-key cryptography base their security on the assumption that the discrete logarithm problem over carefully chosen groups has no efficient solution.},
	language = {en},
	urldate = {2020-04-22},
	journal = {Wikipedia},
	month = apr,
	year = {2020},
	note = {Page Version ID: 950070994},
	file = {Snapshot:/home/jani/Zotero/storage/3AK4RIQ2/index.html:text/html}
}

@misc{noauthor_weak_nodate,
	title = {Weak {Subjectivity} - {Definition}},
	url = {https://www.binance.vision/glossary/weak-subjectivity},
	abstract = {Weak subjectivity {\textbar} Definition: Relates to the need for certain nodes to rely on other nodes when determining the current state of a PoS blockchain.},
	language = {en},
	urldate = {2020-04-22},
	journal = {Binance Academy},
	note = {Library Catalog: www.binance.vision},
	file = {Snapshot:/home/jani/Zotero/storage/UQ92RMGQ/weak-subjectivity.html:text/html}
}

@misc{noauthor_2_nodate,
	title = {(2) {Towards} a scalable and robust {DHT} {\textbar} {Request} {PDF}},
	url = {https://www.researchgate.net/publication/262289324_Towards_a_scalable_and_robust_DHT},
	abstract = {ResearchGate is a network dedicated to science and research. Connect, collaborate and discover scientific publications, jobs and conferences. All for free.},
	language = {en},
	urldate = {2020-04-22},
	journal = {ResearchGate},
	note = {Library Catalog: www.researchgate.net},
	file = {Snapshot:/home/jani/Zotero/storage/UMFPKKPY/262289324_Towards_a_scalable_and_robust_DHT.html:text/html}
}

@misc{noauthor_2_nodate-1,
	title = {(2) {Defending} the {Sybil} attack in {P2P} networks: {Taxonomy}, challenges, and a proposal for self-registration {\textbar} {Request} {PDF}},
	shorttitle = {(2) {Defending} the {Sybil} attack in {P2P} networks},
	url = {https://www.researchgate.net/publication/4238807_Defending_the_Sybil_attack_in_P2P_networks_Taxonomy_challenges_and_a_proposal_for_self-registration},
	abstract = {ResearchGate is a network dedicated to science and research. Connect, collaborate and discover scientific publications, jobs and conferences. All for free.},
	language = {en},
	urldate = {2020-04-22},
	journal = {ResearchGate},
	note = {Library Catalog: www.researchgate.net},
	file = {Snapshot:/home/jani/Zotero/storage/G66RYY27/4238807_Defending_the_Sybil_attack_in_P2P_networks_Taxonomy_challenges_and_a_proposal_for_self-.html:text/html}
}

@incollection{kanade_cryptographic_2004,
	address = {Berlin, Heidelberg},
	title = {Cryptographic {Hash}-{Function} {Basics}: {Definitions}, {Implications}, and {Separations} for {Preimage} {Resistance}, {Second}-{Preimage} {Resistance}, and {Collision} {Resistance}},
	volume = {3017},
	isbn = {978-3-540-22171-5 978-3-540-25937-4},
	shorttitle = {Cryptographic {Hash}-{Function} {Basics}},
	url = {http://link.springer.com/10.1007/978-3-540-25937-4_24},
	abstract = {We consider basic notions of security for cryptographic hash functions: collision resistance, preimage resistance, and second-preimage resistance. We give seven diﬀerent deﬁnitions that correspond to these three underlying ideas, and then we work out all of the implications and separations among these seven deﬁnitions within the concrete-security, provable-security framework. Because our results are concrete, we can show two types of implications, conventional and provisional, where the strength of the latter depends on the amount of compression achieved by the hash function. We also distinguish two types of separations, conditional and unconditional . When constructing counterexamples for our separations, we are careful to preserve speciﬁed hash-function domains and ranges; this rules out some pathological counterexamples and makes the separations more meaningful in practice. Four of our deﬁnitions are standard while three appear to be new; some of our relations and separations have appeared, others have not. Here we give a modern treatment that acts to catalog, in one place and with carefully-considered nomenclature, the most basic security notions for cryptographic hash functions.},
	language = {en},
	urldate = {2020-04-22},
	booktitle = {Fast {Software} {Encryption}},
	publisher = {Springer Berlin Heidelberg},
	author = {Rogaway, Phillip and Shrimpton, Thomas},
	editor = {Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Roy, Bimal and Meier, Willi},
	year = {2004},
	doi = {10.1007/978-3-540-25937-4_24},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {371--388},
	file = {Rogaway and Shrimpton - 2004 - Cryptographic Hash-Function Basics Definitions, I.pdf:/home/jani/Zotero/storage/YLYUU89M/Rogaway and Shrimpton - 2004 - Cryptographic Hash-Function Basics Definitions, I.pdf:application/pdf}
}

@inproceedings{fiat_how_1987,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {How {To} {Prove} {Yourself}: {Practical} {Solutions} to {Identification} and {Signature} {Problems}},
	isbn = {978-3-540-47721-1},
	shorttitle = {How {To} {Prove} {Yourself}},
	doi = {10.1007/3-540-47721-7_12},
	abstract = {In this paper we describe simple identification and signature schemes which enable any user to prove his identity and the authenticity of his messages to any other user without shared or public keys. The schemes are provably secure against any known or chosen message attack if factoring is difficult, and typical implementations require only 1\% to 4\% of the number of modular multiplications required by the RSA scheme. Due to their simplicity, security and speed, these schemes are ideally suited for microprocessor-based devices such as smart cards, personal computers, and remote control systems.},
	language = {en},
	booktitle = {Advances in {Cryptology} — {CRYPTO}’ 86},
	publisher = {Springer},
	author = {Fiat, Amos and Shamir, Adi},
	editor = {Odlyzko, Andrew M.},
	year = {1987},
	keywords = {Authentication Scheme, Credit Card, Security Level, Signature Scheme, Smart Card},
	pages = {186--194},
	file = {Springer Full Text PDF:/home/jani/Zotero/storage/8X79IVVQ/Fiat and Shamir - 1987 - How To Prove Yourself Practical Solutions to Iden.pdf:application/pdf}
}

@inproceedings{shazeer_hydranets_2018,
	address = {Salt Lake City, UT},
	title = {{HydraNets}: {Specialized} {Dynamic} {Architectures} for {Efficient} {Inference}},
	isbn = {978-1-5386-6420-9},
	shorttitle = {{HydraNets}},
	url = {https://ieeexplore.ieee.org/document/8578941/},
	doi = {10.1109/CVPR.2018.00843},
	abstract = {There is growing interest in improving the design of deep network architectures to be both accurate and low cost. This paper explores semantic specialization as a mechanism for improving the computational efﬁciency (accuracyper-unit-cost) of inference in the context of image classiﬁcation. Speciﬁcally, we propose a network architecture template called HydraNet, which enables state-of-the-art architectures for image classiﬁcation to be transformed into dynamic architectures which exploit conditional execution for efﬁcient inference. HydraNets are wide networks containing distinct components specialized to compute features for visually similar classes, but they retain efﬁciency by dynamically selecting only a small number of components to evaluate for any one input image. This design is made possible by a soft gating mechanism that encourages component specialization during training and accurately performs component selection during inference. We evaluate the HydraNet approach on both the CIFAR-100 and ImageNet classiﬁcation tasks. On CIFAR, applying the HydraNet template to the ResNet and DenseNet family of models reduces inference cost by 2-4× while retaining the accuracy of the baseline architectures. On ImageNet, applying the HydraNet template improves accuracy up to 2.5\% when compared to an efﬁcient baseline architecture with similar inference cost.},
	language = {en},
	urldate = {2020-04-23},
	booktitle = {2018 {IEEE}/{CVF} {Conference} on {Computer} {Vision} and {Pattern} {Recognition}},
	publisher = {IEEE},
	author = {Shazeer, Noam and Fatahalian, Kayvon and Mark, William R. and Mullapudi, Ravi Teja},
	month = jun,
	year = {2018},
	pages = {8080--8089},
	file = {Shazeer et al. - 2018 - HydraNets Specialized Dynamic Architectures for E.pdf:/home/jani/Zotero/storage/IWJVL796/Shazeer et al. - 2018 - HydraNets Specialized Dynamic Architectures for E.pdf:application/pdf}
}

@misc{noauthor_tcp_nodate,
	title = {{TCP} ex {Machina}},
	url = {https://web.mit.edu/remy/},
	urldate = {2020-05-06},
	file = {TCP ex Machina:/home/jani/Zotero/storage/FWDKCE82/remy.html:text/html}
}

@article{moltchanov_selected_nodate,
	title = {Selected {DHT} algorithms: {Chord} and {Pastry}},
	language = {en},
	author = {Moltchanov, Dmitri},
	pages = {34},
	file = {Moltchanov - Selected DHT algorithms Chord and Pastry.pdf:/home/jani/Zotero/storage/FGKXFXRC/Moltchanov - Selected DHT algorithms Chord and Pastry.pdf:application/pdf}
}

@inproceedings{diaz_impact_2010,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Impact of {Network} {Topology} on {Anonymity} and {Overhead} in {Low}-{Latency} {Anonymity} {Networks}},
	isbn = {978-3-642-14527-8},
	doi = {10.1007/978-3-642-14527-8_11},
	abstract = {Low-latency anonymous communication networks require padding to resist timing analysis attacks, and dependent link padding has been proven to prevent these attacks with minimal overhead. In this paper we consider low-latency anonymity networks that implement dependent link padding, and examine various network topologies. We find that the choice of the topology has an important influence on the padding overhead and the level of anonymity provided, and that Stratified networks offer the best trade-off between them. We show that fully connected network topologies (Free Routes) are impractical when dependent link padding is used, as they suffer from feedback effects that induce disproportionate amounts of padding; and that Cascade topologies have the lowest padding overhead at the cost of poor scalability with respect to anonymity. Furthermore, we propose an variant of dependent link padding that considerably reduces the overhead at no loss in anonymity with respect to external adversaries. Finally, we discuss how Tor, a deployed large-scale anonymity network, would need to be adapted to support dependent link padding.},
	language = {en},
	booktitle = {Privacy {Enhancing} {Technologies}},
	publisher = {Springer},
	author = {Diaz, Claudia and Murdoch, Steven J. and Troncoso, Carmela},
	editor = {Atallah, Mikhail J. and Hopper, Nicholas J.},
	year = {2010},
	keywords = {Entry Node, Exit Node, Middle Node, Network Topology, Real Cell},
	pages = {184--201},
	file = {Diaz et al_2010_Impact of Network Topology on Anonymity and Overhead in Low-Latency Anonymity.pdf:/home/jani/Zotero/storage/RWK4U8EK/Diaz et al_2010_Impact of Network Topology on Anonymity and Overhead in Low-Latency Anonymity.pdf:application/pdf}
}

@misc{noauthor_roughtime_2018,
	title = {Roughtime: {Securing} {Time} with {Digital} {Signatures}},
	shorttitle = {Roughtime},
	url = {https://blog.cloudflare.com/roughtime/},
	abstract = {When you visit a secure website, it offers you a TLS certificate that asserts its identity. Every certificate has an expiration date, and when it’s passed due, it is no longer valid.},
	language = {en},
	urldate = {2020-05-05},
	journal = {The Cloudflare Blog},
	month = sep,
	year = {2018},
	note = {Library Catalog: blog.cloudflare.com},
	file = {Snapshot:/home/jani/Zotero/storage/RN55PKF7/roughtime.html:text/html}
}

@article{eng_keong_lua_survey_2005,
	title = {A survey and comparison of peer-to-peer overlay network schemes},
	volume = {7},
	issn = {1553-877X},
	url = {http://ieeexplore.ieee.org/document/1610546/},
	doi = {10.1109/COMST.2005.1610546},
	abstract = {Over the Internet today, computing and communications environments are signiﬁcantly more complex and chaotic than classical distributed systems, lacking any centralized organization or hierarchical control. There has been much interest in emerging Peer-to-Peer (P2P) network overlays because they provide a good substrate for creating large-scale data sharing, content distribution and application-level multicast applications. These P2P networks try to provide a long list of features such as: selection of nearby peers, redundant storage, efﬁcient search/location of data items, data permanence or guarantees, hierarchical naming, trust and authentication, and, anonymity. P2P networks potentially offer an efﬁcient routing architecture that is self-organizing, massively scalable, and robust in the wide-area, combining fault tolerance, load balancing and explicit notion of locality. In this paper, we present a survey and comparison of various Structured and Unstructured P2P networks. We categorize the various schemes into these two groups in the design spectrum and discuss the application-level network performance of each group.},
	language = {en},
	number = {2},
	urldate = {2020-05-05},
	journal = {IEEE Communications Surveys \& Tutorials},
	author = {{Eng Keong Lua} and Crowcroft, J. and Pias, M. and Sharma, R. and Lim, S.},
	year = {2005},
	pages = {72--93},
	file = {Eng Keong Lua et al. - 2005 - A survey and comparison of peer-to-peer overlay ne.pdf:/home/jani/Zotero/storage/Q3R3KIPL/Eng Keong Lua et al. - 2005 - A survey and comparison of peer-to-peer overlay ne.pdf:application/pdf}
}

@article{haleem_decentralized_nodate,
	title = {A {Decentralized} {Wireless} {Network}},
	abstract = {The Internet of Things is an \$800 billion industry, with over 8.4 billion connected devices online, and spending predicted to reach nearly \$1.4 trillion by 2021 [1]. Most of these devices need to connect to the Internet to function. However, current solutions such as cellular, WiFi, and Bluetooth are suboptimal: they are too expensive, too power hungry, or too limited in range.},
	language = {en},
	author = {Haleem, Amir and Allen, Andrew and Thompson, Andrew and Nijdam, Marc and Garg, Rahul},
	pages = {20},
	file = {Haleem et al. - A Decentralized Wireless Network.pdf:/home/jani/Zotero/storage/VV82HS83/Haleem et al. - A Decentralized Wireless Network.pdf:application/pdf}
}

@book{graham_secure_1978,
	title = {Secure {Communications} {Over} {Insecure} {Channels}},
	abstract = {According to traditional conceptions of cryptographic security, it is necessary to transmit a key, by secret means, before encrypted messages can be sent securely. This paper shows that it is possible to select a key over open communications channels in such a fashion that communications security can be maintained. A method is described which forces any enemy to expend an amount of work which increases as the square of the work required of the two communicants to select the key. The method provides a logically new kind of protection against the passive eavesdropper. It suggests that further research on this topic will be highly rewarding, both in a theoretical and a practical sense. Key Words and Phrases: security, cryptography, cryptology, communications security, wiretap, computer network security, passive eavesdropping, key distribution, public key cryptosystem CR Categories:.3.56, 3.81 294 General permission to make fair use in teaching or research of all or part of this material is granted to individual readers and to nonprofit libraries acting for them provided that ACM's copyright notice is given and that reference is made to the publication, to its date of issue, and to the fact that reprinting privileges were granted by permission of the Association for Computing Machinery. To otherwise reprint a figure, table, other substantial excerpt, or the entire work requires specific permission as does republication, or systematic or multiple reproduction.},
	author = {Graham, S. L. and Rivest, R. L. and Merkle, Ralph C.},
	year = {1978},
	file = {Citeseer - Snapshot:/home/jani/Zotero/storage/58RDDDS5/summary.html:text/html;Graham et al_1978_Secure Communications Over Insecure Channels.pdf:/home/jani/Zotero/storage/Z9T3PVTZ/Graham et al_1978_Secure Communications Over Insecure Channels.pdf:application/pdf}
}

@incollection{gollmann_cmix_2017,
	address = {Cham},
	title = {{cMix}: {Mixing} with {Minimal} {Real}-{Time} {Asymmetric} {Cryptographic} {Operations}},
	volume = {10355},
	isbn = {978-3-319-61203-4 978-3-319-61204-1},
	shorttitle = {{cMix}},
	url = {http://link.springer.com/10.1007/978-3-319-61204-1_28},
	abstract = {We introduce cMix, a new approach to anonymous communications. Through a precomputation, the core cMix protocol eliminates all expensive real- time public-key operations—at the senders, recipients and mixnodes—thereby decreasing real-time cryptographic latency and lowering computational costs for clients. The core real-time phase performs only a few fast modular multiplica- tions. In these times of surveillance and extensive profiling there is a great need for an anonymous communication system that resists global attackers. One widely rec- ognized solution to the challenge of traffic analysis is a mixnet, which anonymizes a batch of messages by sending the batch through a fixed cascade of mixnodes. Mixnets can offer excellent privacy guarantees, including unlinkability of sender and receiver, and resistance to many traffic-analysis attacks that undermine many other approaches including onion routing. Existing mixnet designs, however, suf- fer from high latency in part because of the need for real-time public-key opera- tions. Precomputation greatly improves the real-time performance of cMix, while its fixed cascade of mixnodes yields the strong anonymity guarantees of mixnets. cMix is unique in not requiring any real-time public-key operations by users. Consequently, cMix is the first mixing suitable for low latency chat for light- weight devices. Our presentation includes a specification of cMix, security arguments, anonymity analysis, and a performance comparison with selected other approaches. We also give benchmarks from our prototype.},
	language = {en},
	urldate = {2020-05-04},
	booktitle = {Applied {Cryptography} and {Network} {Security}},
	publisher = {Springer International Publishing},
	author = {Chaum, David and Das, Debajyoti and Javani, Farid and Kate, Aniket and Krasnova, Anna and De Ruiter, Joeri and Sherman, Alan T.},
	editor = {Gollmann, Dieter and Miyaji, Atsuko and Kikuchi, Hiroaki},
	year = {2017},
	doi = {10.1007/978-3-319-61204-1_28},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {557--578},
	file = {Chaum et al. - 2017 - cMix Mixing with Minimal Real-Time Asymmetric Cry.pdf:/home/jani/Zotero/storage/23NM7HTG/Chaum et al. - 2017 - cMix Mixing with Minimal Real-Time Asymmetric Cry.pdf:application/pdf}
}

@article{henningsen_eclipsing_2019,
	title = {Eclipsing {Ethereum} {Peers} with {False} {Friends}},
	url = {http://arxiv.org/abs/1908.10141},
	abstract = {Ethereum is a decentralized Blockchain system that supports the execution of Turing-complete smart contracts. Although the security of the Ethereum ecosystem has been studied in the past, the network layer has been mostly neglected. We show that Go Ethereum (Geth), the most widely used Ethereum implementation, is vulnerable to eclipse attacks, effectively circumventing recently introduced (Geth v1.8.0) security enhancements. We responsibly disclosed the vulnerability to core Ethereum developers; the corresponding countermeasures to our attack where incorporated into the v1.9.0 release of Geth. Our false friends attack exploits the Kademlia-inspired peer discovery logic used by Geth and enables a low-resource eclipsing of long-running, remote victim nodes. An adversary only needs two hosts in distinct /24 subnets to launch the eclipse, which can then be leveraged to filter the victim's view of the Blockchain. We discuss fundamental properties of Geth's node discovery logic that enable the false friends attack, as well as proposed and implemented countermeasures.},
	urldate = {2020-05-04},
	journal = {arXiv:1908.10141 [cs]},
	author = {Henningsen, Sebastian and Teunis, Daniel and Florian, Martin and Scheuermann, Björn},
	month = aug,
	year = {2019},
	note = {arXiv: 1908.10141},
	keywords = {Computer Science - Cryptography and Security, Computer Science - Networking and Internet Architecture},
	annote = {Comment: Extended version of the original publication in: 2019 IEEE European Symposium on Security and Privacy Workshops (EuroS\&PW)},
	file = {arXiv.org Snapshot:/home/jani/Zotero/storage/LUAZ587M/1908.html:text/html;Henningsen et al_2019_Eclipsing Ethereum Peers with False Friends.pdf:/home/jani/Zotero/storage/EP6VR9ZB/Henningsen et al_2019_Eclipsing Ethereum Peers with False Friends.pdf:application/pdf}
}

@misc{nym_sphinx_2020,
	title = {Sphinx: {The} anonymous data format behind {Lightning} and {Nym}},
	shorttitle = {Sphinx},
	url = {https://medium.com/nymtech/sphinx-tl-dr-the-data-packet-that-can-anonymize-bitcoin-and-the-internet-18d152c6e4dc},
	abstract = {Sphinx is an anonymous cryptographic packet format without precedent, and it powers both the Lightning Network and Nym. This is how it…},
	language = {en},
	urldate = {2020-05-04},
	journal = {Medium},
	author = {Nym},
	month = feb,
	year = {2020},
	note = {Library Catalog: medium.com},
	file = {Snapshot:/home/jani/Zotero/storage/9DAYPZUG/sphinx-tl-dr-the-data-packet-that-can-anonymize-bitcoin-and-the-internet-18d152c6e4dc.html:text/html}
}

@article{piotrowska_loopix_2017,
	title = {The {Loopix} {Anonymity} {System}},
	url = {http://arxiv.org/abs/1703.00536},
	abstract = {We present Loopix, a low-latency anonymous communication system that provides bi-directional 'third-party' sender and receiver anonymity and unobservability. Loopix leverages cover traffic and brief message delays to provide anonymity and achieve traffic analysis resistance, including against a global network adversary. Mixes and clients self-monitor the network via loops of traffic to provide protection against active attacks, and inject cover traffic to provide stronger anonymity and a measure of sender and receiver unobservability. Service providers mediate access in and out of a stratified network of Poisson mix nodes to facilitate accounting and off-line message reception, as well as to keep the number of links in the system low, and to concentrate cover traffic. We provide a theoretical analysis of the Poisson mixing strategy as well as an empirical evaluation of the anonymity provided by the protocol and a functional implementation that we analyze in terms of scalability by running it on AWS EC2. We show that a Loopix relay can handle upwards of 300 messages per second, at a small delay overhead of less than 1.5 ms on top of the delays introduced into messages to provide security. Overall message latency is in the order of seconds - which is low for a mix-system. Furthermore, many mix nodes can be securely added to a stratified topology to scale throughput without sacrificing anonymity.},
	urldate = {2020-05-04},
	journal = {arXiv:1703.00536 [cs]},
	author = {Piotrowska, Ania and Hayes, Jamie and Elahi, Tariq and Meiser, Sebastian and Danezis, George},
	month = mar,
	year = {2017},
	note = {arXiv: 1703.00536},
	keywords = {Computer Science - Cryptography and Security},
	file = {arXiv.org Snapshot:/home/jani/Zotero/storage/IWWXJFB7/1703.html:text/html;Piotrowska et al_2017_The Loopix Anonymity System.pdf:/home/jani/Zotero/storage/YRLDY3XB/Piotrowska et al_2017_The Loopix Anonymity System.pdf:application/pdf}
}

@article{kelner_electric_nodate,
	title = {Electric routing and concurrent flow cutting},
	language = {en},
	author = {Kelner, Jonathan},
	pages = {39},
	file = {Kelner - Electric routing and concurrent flow cutting.pdf:/home/jani/Zotero/storage/Q3MW6GZK/Kelner - Electric routing and concurrent flow cutting.pdf:application/pdf}
}

@misc{veradittakit_veradiverdict_nodate,
	title = {{VeradiVerdict} - {What} {Does} {Layer} 0/{BDN} {For} {Scalability} {Look} {Like}? - {Issue} \#38},
	shorttitle = {{VeradiVerdict} - {What} {Does} {Layer} 0/{BDN} {For} {Scalability} {Look} {Like}?},
	url = {https://veradiverdict.substack.com/p/veradiverdict-what-does-layer-0-bdn},
	abstract = {Hi, I am Paul Veradittakit, a Partner at Pantera Capital, one of the oldest and largest institutional investors focused on investing into blockchain companies and cryptocurrencies. I focus on early investments and want to share my thoughts and what’s going on in the industry in this weekly newsletter.},
	urldate = {2020-04-29},
	author = {Veradittakit, Paul},
	note = {Library Catalog: veradiverdict.substack.com},
	file = {Snapshot:/home/jani/Zotero/storage/3LTSNKIB/veradiverdict-what-does-layer-0-bdn.html:text/html}
}

@article{uri_klarman_soumya_basu_aleksandar_kuzmanovic_emin_gun_sirer_bloxroute_nodate,
	title = {{bloXroute}: {A} {Scalable} {Trustless} {Blockchain} {Distribution} {Network}},
	author = {Uri Klarman, Soumya Basu, Aleksandar Kuzmanovic, Emin Gun Sirer},
	file = {Uri Klarman, Soumya Basu, Aleksandar Kuzmanovic, Emin Gun Sirer_bloXroute.pdf:/home/jani/Zotero/storage/TZMKFTGN/Uri Klarman, Soumya Basu, Aleksandar Kuzmanovic, Emin Gun Sirer_bloXroute.pdf:application/pdf}
}

@article{boneh_graduate_nodate,
	title = {A {Graduate} {Course} in {Applied} {Cryptography}},
	language = {en},
	author = {Boneh, Dan and Shoup, Victor},
	pages = {900},
	file = {Boneh and Shoup - A Graduate Course in Applied Cryptography.pdf:/home/jani/Zotero/storage/DBLZUZR3/Boneh and Shoup - A Graduate Course in Applied Cryptography.pdf:application/pdf}
}

@inproceedings{freedman_non-transitive_2005,
	address = {San Francisco, CA},
	series = {{WORLDS}'05},
	title = {Non-transitive connectivity and {DHTs}},
	urldate = {2020-04-29},
	booktitle = {Proceedings of the 2nd conference on {Real}, {Large} {Distributed} {Systems} - {Volume} 2},
	publisher = {USENIX Association},
	author = {Freedman, Michael J. and Lakshminarayanan, Karthik and Rhea, Sean and Stoica, Ion},
	month = dec,
	year = {2005},
	pages = {55--60}
}

@article{freedman_democratizing_nodate,
	title = {Democratizing content publication with {Coral}},
	abstract = {CoralCDN is a peer-to-peer content distribution network that allows a user to run a web site that offers high performance and meets huge demand, all for the price of a cheap broadband Internet connection. Volunteer sites that run CoralCDN automatically replicate content as a side effect of users accessing it. Publishing through CoralCDN is as simple as making a small change to the hostname in an object’s URL; a peer-to-peer DNS layer transparently redirects browsers to nearby participating cache nodes, which in turn cooperate to minimize load on the origin web server. One of the system’s key goals is to avoid creating hot spots that might dissuade volunteers and hurt performance. It achieves this through Coral, a latency-optimized hierarchical indexing infrastructure based on a novel abstraction called a distributed sloppy hash table, or DSHT.},
	language = {en},
	author = {Freedman, Michael J and Freudenthal, Eric and Mazieres, David},
	pages = {14},
	file = {Freedman et al. - Democratizing content publication with Coral.pdf:/home/jani/Zotero/storage/5SF3RAUZ/Freedman et al. - Democratizing content publication with Coral.pdf:application/pdf}
}

@misc{noauthor_vdf_nodate-2,
	title = {{VDF} {Alliance}},
	url = {https://www.vdfalliance.org},
	abstract = {The VDF Alliance is a collection of academic, non-profit, and corporate collaborators building open source hardware for the blockchain ecosystem   Help Us Build},
	language = {en-US},
	urldate = {2020-04-29},
	journal = {VDF Alliance},
	note = {Library Catalog: www.vdfalliance.org},
	file = {Snapshot:/home/jani/Zotero/storage/GBWBB6MU/www.vdfalliance.org.html:text/html}
}

@misc{noauthor_supranationalvdf-fpga_2020,
	title = {supranational/vdf-fpga},
	url = {https://github.com/supranational/vdf-fpga},
	abstract = {Implementation of an RSA VDF evaluator targeting FPGAs.},
	urldate = {2020-04-29},
	publisher = {Supranational},
	month = apr,
	year = {2020},
	note = {original-date: 2019-06-21T20:19:38Z}
}

@misc{noauthor_time_2019,
	title = {Time, {Randomness}, and a \$100,000 {Prize} to {Forever} {Change} {Blockchain}},
	url = {https://aws.amazon.com/blogs/startups/competition-forever-change-blockchain/},
	abstract = {Announcing an open source hardware competition to change how blocks (as in blockchain) are produced using far less energy. And on the way, finding a solution to move from proof of work to proof of stake.},
	language = {en-US},
	urldate = {2020-04-29},
	journal = {Amazon Web Services},
	month = aug,
	year = {2019},
	note = {Library Catalog: aws.amazon.com
Section: Startup},
	file = {Snapshot:/home/jani/Zotero/storage/5NWQ6YA4/competition-forever-change-blockchain.html:text/html}
}

@misc{research_single_nodate,
	title = {Single {Secret} {Leader} {Election}},
	url = {https://research.protocol.ai/research/publications/single-secret-leader-election/},
	abstract = {In a Single Secret Leader Election (SSLE), a group of participants aim to randomly choose exactly one leader from the group with the restriction that the identity of the leader will be known to the chosen leader and nobody else.},
	language = {en},
	urldate = {2020-04-29},
	journal = {Protocol Labs Research},
	author = {Research, Protocol Labs},
	note = {Library Catalog: research.protocol.ai},
	file = {Snapshot:/home/jani/Zotero/storage/FD235UEP/single-secret-leader-election.html:text/html}
}

@inproceedings{freedman_sloppy_2003,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Sloppy {Hashing} and {Self}-{Organizing} {Clusters}},
	isbn = {978-3-540-45172-3},
	doi = {10.1007/978-3-540-45172-3_4},
	abstract = {We are building Coral, a peer-to-peer content distribution system. Coral creates self-organizing clusters of nodes that fetch information from each other to avoid communicating with more distant or heavily-loaded servers. Coral indexes data, but does not store it. The actual content resides where it is used, such as in nodes’ local web caches. Thus, replication happens exactly in proportion to demand. We present two novel mechanisms that let Coral achieve scalability and high performance. First, a new abstraction called a distributed sloppy hash table (DSHT) lets nodes locate nearby copies of a file, regardless of its popularity, without causing hot spots in the indexing infrastructure. Second, based on the DSHT interface, we introduce a decentralized clustering algorithm by which nodes can find each other and form clusters of varying network diameters.},
	language = {en},
	booktitle = {Peer-to-{Peer} {Systems} {II}},
	publisher = {Springer},
	author = {Freedman, Michael J. and Maziéres, David},
	editor = {Kaashoek, M. Frans and Stoica, Ion},
	year = {2003},
	pages = {45--55},
	file = {Freedman_Maziéres_2003_Sloppy Hashing and Self-Organizing Clusters.pdf:/home/jani/Zotero/storage/A2ZWHWZU/Freedman_Maziéres_2003_Sloppy Hashing and Self-Organizing Clusters.pdf:application/pdf}
}

@inproceedings{yu_sybillimit_2008,
	title = {{SybilLimit}: {A} {Near}-{Optimal} {Social} {Network} {Defense} against {Sybil} {Attacks}},
	shorttitle = {{SybilLimit}},
	doi = {10.1109/SP.2008.13},
	abstract = {Decentralized distributed systems such as peer-to-peer systems are particularly vulnerable to sybil attacks, where a malicious user pretends to have multiple identities (called sybil nodes). Without a trusted central authority, defending against sybil attacks is quite challenging. Among the small number of decentralized approaches, our recent SybilGuard protocol [H. Yu et al., 2006] leverages a key insight on social networks to bound the number of sybil nodes accepted. Although its direction is promising, SybilGuard can allow a large number of sybil nodes to be accepted. Furthermore, SybilGuard assumes that social networks are fast mixing, which has never been confirmed in the real world. This paper presents the novel SybilLimit protocol that leverages the same insight as SybilGuard but offers dramatically improved and near-optimal guarantees. The number of sybil nodes accepted is reduced by a factor of ominus(radicn), or around 200 times in our experiments for a million-node system. We further prove that SybilLimit's guarantee is at most a log n factor away from optimal, when considering approaches based on fast-mixing social networks. Finally, based on three large-scale real-world social networks, we provide the first evidence that real-world social networks are indeed fast mixing. This validates the fundamental assumption behind SybilLimit's and SybilGuard's approach.},
	booktitle = {2008 {IEEE} {Symposium} on {Security} and {Privacy} (sp 2008)},
	author = {Yu, Haifeng and Gibbons, Phillip B. and Kaminsky, Michael and Xiao, Feng},
	month = may,
	year = {2008},
	note = {ISSN: 2375-1207},
	keywords = {peer-to-peer computing, protocols, Protocols, Sybil attack, Collaboration, decentralized distributed system, distributed processing, fast mixing social network, Humans, Large-scale systems, malicious user, million-node system, multiple identity, National security, near-optimal social network defense, Peer to peer computing, peer-to-peer system, Privacy, Routing, security of data, Social network services, social networks, sybil attack, sybil identity, sybil nodes, SybilGuard protocol, SybilLimit, SybilLimit protocol, Voting},
	pages = {3--17},
	file = {IEEE Xplore Abstract Record:/home/jani/Zotero/storage/F2XDKF57/4531141.html:text/html;Yu et al_2008_SybilLimit.pdf:/home/jani/Zotero/storage/2TDXPEFY/Yu et al_2008_SybilLimit.pdf:application/pdf}
}

@techreport{lindell_fast_2017,
	title = {Fast {Secure} {Two}-{Party} {ECDSA} {Signing}},
	url = {http://eprint.iacr.org/2017/552},
	abstract = {ECDSA is a standard digital signature schemes that is widely used in TLS, Bitcoin and elsewhere. Unlike other schemes like RSA, Schnorr signatures and more, it is particularly hard to construct efficient threshold signature protocols for ECDSA (and DSA). As a result, the best-known protocols today for secure distributed ECDSA require running heavy zero-knowledge proofs and computing many large-modulus exponentiations for every signing operation. In this paper, we consider the specific case of two parties (and thus no honest majority) and construct a protocol that is approximately {\textbackslash}textit\{two orders of magnitude faster\} than the previous best. Concretely, our protocol achieves good performance, with a single signing operation for curve P-256 taking approximately 37ms between two standard machine types in Azure (utilizing a single core only). Our protocol is proven secure under standard assumptions using a game-based definition. In addition, we prove security by simulation under a plausible yet non-standard assumption regarding Paillier.},
	number = {552},
	urldate = {2020-04-28},
	author = {Lindell, Yehuda},
	year = {2017},
	keywords = {distributed signing, ECDSA},
	file = {ePrint IACR Snapshot:/home/jani/Zotero/storage/3K7D7VY2/552.html:text/html;Lindell_2017_Fast Secure Two-Party ECDSA Signing.pdf:/home/jani/Zotero/storage/AVC27Y2M/Lindell_2017_Fast Secure Two-Party ECDSA Signing.pdf:application/pdf}
}

@misc{noauthor_notitle_nodate,
	url = {https://blog.ipfs.io/2020-04-28-go-ipfs-0-5-0/},
	urldate = {2020-04-28},
	file = {:/home/jani/Zotero/storage/M5DE832M/2020-04-28-go-ipfs-0-5-0.html:text/html}
}

@article{rivest_time-lock_nodate,
	title = {Time-lock puzzles and timed-release {Crypto}},
	language = {en},
	author = {Rivest, Ronald L and Shamir, Adi and Wagner, David A},
	pages = {9},
	file = {Rivest et al. - Time-lock puzzles and timed-release Crypto.pdf:/home/jani/Zotero/storage/YUY9ILGW/Rivest et al. - Time-lock puzzles and timed-release Crypto.pdf:application/pdf}
}

@inproceedings{heilman_eclipse_2015,
	title = {Eclipse {Attacks} on {Bitcoin}’s {Peer}-to-{Peer} {Network}},
	isbn = {978-1-939133-11-3},
	url = {https://www.usenix.org/node/190891},
	language = {en},
	urldate = {2020-05-13},
	author = {Heilman, Ethan and Kendler, Alison and Zohar, Aviv and Goldberg, Sharon},
	year = {2015},
	pages = {129--144},
	file = {Full Text PDF:/home/jani/Zotero/storage/C8I97SQD/Heilman et al. - 2015 - Eclipse Attacks on Bitcoin’s Peer-to-Peer Network.pdf:application/pdf}
}

@misc{grigorik_latency_nodate,
	title = {Latency: {The} {New} {Web} {Performance} {Bottleneck} - igvita.com},
	shorttitle = {Latency},
	url = {https://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck/},
	abstract = {'High speed' connectivity is not all about bandwidth, latency is the new bottleneck for most web browsing applications - especially, for the mobile web.},
	language = {en},
	urldate = {2020-05-13},
	author = {Grigorik, Ilya},
	note = {Library Catalog: www.igvita.com},
	file = {Snapshot:/home/jani/Zotero/storage/V2R2WNNZ/latency-the-new-web-performance-bottleneck.html:text/html}
}

@incollection{robertazzi_space_2017,
	address = {Cham},
	title = {Space {Networking}},
	isbn = {978-3-319-53103-8},
	url = {https://doi.org/10.1007/978-3-319-53103-8_9},
	abstract = {Networks that are used in space are considered. SpaceWire and SpaceFibre internal networking technology for spacecraft is examined. Space communications between the Earth and spacecraft is covered. Also discussed are the Deep Space Network, Disruption Tolerant Networks, the Bundle protocol for space networking, and Contact Graph Routing.},
	language = {en},
	urldate = {2020-05-14},
	booktitle = {Introduction to {Computer} {Networking}},
	publisher = {Springer International Publishing},
	author = {Robertazzi, Thomas G.},
	editor = {Robertazzi, Thomas G.},
	year = {2017},
	doi = {10.1007/978-3-319-53103-8_9},
	keywords = {Bundle protocol, Contact graph routing, Deep space network, Delay tolerant networks, Disruption tolerant networks, Space networks, SpaceFibre, SpaceWire},
	pages = {97--112},
	file = {Robertazzi_2017_Space Networking.pdf:/home/jani/Zotero/storage/RZ3ZHADA/Robertazzi_2017_Space Networking.pdf:application/pdf}
}

@misc{tung_elon_nodate,
	title = {Elon {Musk}: {SpaceX}'s internet from space should be good enough for online gaming},
	shorttitle = {Elon {Musk}},
	url = {https://www.zdnet.com/article/elon-musk-spacexs-internet-from-space-should-be-good-enough-for-online-gaming/},
	abstract = {Elon Musk estimates Starlink will only serve the 3\% to 4\% of the population that telcos can't currently cater for.},
	language = {en},
	urldate = {2020-05-14},
	journal = {ZDNet},
	author = {Tung, Liam},
	note = {Library Catalog: www.zdnet.com},
	file = {Snapshot:/home/jani/Zotero/storage/BUTZ3SJB/elon-musk-spacexs-internet-from-space-should-be-good-enough-for-online-gaming.html:text/html}
}

@misc{noauthor_satellite_nodate,
	title = {Satellite {Internet} {Latency} - {VSAT} {Systems} {Broadband} {Satellite} {Internet} {Latency} - {Broadband} {Satellite} {Internet} {Service} {Latency}},
	url = {https://www.vsat-systems.com/satellite-internet-explained/latency.html},
	urldate = {2020-05-14},
	file = {Satellite Internet Latency - VSAT Systems Broadband Satellite Internet Latency - Broadband Satellite Internet Service Latency:/home/jani/Zotero/storage/BJXUVIIT/latency.html:text/html}
}
