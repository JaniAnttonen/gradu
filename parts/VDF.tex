% !TeX root = ./Thesis.tex
\chapter{Verifiable Delay Functions}
\label{Verifiable Delay Functions}



%TODO add an intro on VDFs from the boneh paper
\section{History}
Verifiable delay functions are based on time-lock puzzles. Like VDF's, time-lock puzzles are computational sequential puzzles that require a certain amount of time to solve.\cite{Rivest_undated-qr} Time-lock puzzles were originally created to send information into the future, which simplifies into a cryptographic time capsule. Ronald L. Rivest, Adi Shamir, and David A. Wagner classify time-lock puzzles generally under the term timed-release crypto in their 1996 paper. They describe the envisioned use cases for timed-release crypto as being the following, although they're very similar with the general concept of sending information into the future:

\begin{itemize}
  \item A bidder in an auction wants to seal his bid so that it can only be opened after the bidding period is closed 
  \item A homeowner wants to give his mortgage holder a series of encrypted mortgage payments. These might be encrypted digital cash with different decryption dates so that one payment becomes decryptable and thus usable by the bank at the beginning of each successive month
  \item An individual wants to encrypt his diaries so that they are only decryptable after fifty years.
  \item A key escrow scheme can be based on timed-release crypto so that the government can get the message keys but only after a fixed period, say one year
\end{itemize}

Verifiable delay functions fall under the same definition, but introduce a publicly verifiable proof that is much faster to verify than the puzzle was to solve. The original motivation for verifiable delay functions was to enable someone to pick off where somebody else had left when calculating a time puzzle - to make it possible to create checkpoints in the calculation that could be trusted.

\section{Use Cases}
Many have shown that there are more use cases for these algoritms than puzzles and random number generators. Some examples include preventing front running in p2p cryptocurrency exchanges, spam prevention and rate limiting\cite{noauthor_undated-hk}

Almost all use cases are based on the property that with a new unique input, and a difficulty requirement, there is no easy way to speed up the calculation. In the front running use case, this property can be used to remove the effects of latency to prevent any peer, that has heard of a trade happening before another, that has already committed to it, to do a similar trade and get their message across first.\cite{Cline2020-wb} The problem arises from the way messages propagate through a p2p network.

\section{Variations}
There are multiple variations on the security principles used, since a VDF can use any group of unknown order as a basis for its unpredictability.

\section{Similar Constructs}
A VDF can only be calculated sequentially, but even without a proof there is a possibility to make the verification faster through parallellism. A non-verifiable delay function, or time-lock puzzle in short, can be still verified faster than the calculation, because there is no sequential requirement after the puzzle has been calculated, enabling to use multiple CPU cores or highly parallel graphics processing units for verifying the puzzle, like in Solana.\cite{Yakovenko2018-zn} 

\section{Hardware Developments}
All VDF applications can be made faster with hardware, and it has been estimated that with an ASIC chip a VDF can be calculated more than ten times faster than with a GPU.\cite{Stanford_Video2020-ap} If or when hardware specifically optimized for sequential squarings is commercialized, VDFs can become much more mainstream, and suffer less from computational differences, thus requiring less trust between the calculating parties.

Besides the development in the ASIC department driven by vdfresearch.org\cite{noauthor_undated-hk}, there's been development on CPU instructions by Intel, aiming to help the specific operation of modular exponentiation, which is used not only in VDFs, but also in classical RSA, DSA, and DH algorithms, not to mention homomorphic encryption.\cite{Drucker2019-cx} 
